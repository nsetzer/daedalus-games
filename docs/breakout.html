<!--daedalus build --htmlname breakout.html --onefile --paths=./src src/breakout/breakout2.js ./docs-->
<!DOCTYPE html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
<html lang="en">
<head>
<title>Daedalus</title>
<link rel="icon" type="image/x-icon" href="/favicon.ico" />
<style type="text/css">
.dcs-16e24fb6-0 {cursor:pointer;color:blue}
.dcs-16e24fb6-1 {background-color:#edf2f7;border:2px dashed #cbd5e0;width:100%;height:100%}
.dcs-3c12219a-0 {border:0px;margin:0;padding:0;cursor:pointer}
.dcs-702cb152-0 {background:#333333;overflow:scroll;margin:0;padding:0}
.dcs-702cb152-1 {background:#333333;overflow:scroll;margin:0;padding:0;transform-origin:top left;transform:translate(100vw, 30vh) rotate(90deg);}
.dcs-702cb152-2 {display:flex;flex-direction:row;justify-content:center}
.dcs-702cb152-3 {background:#0000CC22}
.dcs-702cb152-4 {}
.dcs-702cb152-5 {color:blue;cursor:pointer}
</style>

<script type="text/javascript">
daedalus=(function(){
    "use strict";
    const env={};
    const build_platform="web";
    const[StyleSheet,getStyleSheet,parseParameters,util]=(function(){
        function array_move(arr,p1,p2){
          if(p1<0){
            p1=0;
          }
          if(p2<0){
            p2=0;
          }
          if(p1>arr.length){
            p1=arr.length;
          }
          if(p2>arr.length){
            p2=arr.length;
          }
          if(p1==p2){
            return;
          }
          arr.splice(p2,0,arr.splice(p1,1)[0]);
          return;
        }
        function randomFloat(min,max){
          return Math.random()*(max-min)+min;
        }
        function randomInt(min,max){
          let _rnd=Math.random();
          let _min=Math.ceil(min);
          let _max=Math.floor(max);
          return Math.floor(_rnd*(_max-_min+1))+_min;
        }
        function object2style_helper(prefix,obj){
          const items=Object.keys(obj).map(key=>{
              const val=obj[key];
              const type=typeof(val);
              if(type==="object"){
                return object2style_helper(prefix+key+"-",val);
              }else{
                return[prefix+key+": "+val];
              }
            });
          let out=[];
          for(let i=0;i<items.length;i++)
          {
            out.concat(items[i]);
          }
          return out;
        }
        function object2style(obj){
          const arr=object2style_helper("",obj);
          return[].concat(arr).join(';');
        }
        function serializeParameters(obj){
          if(Object.keys(obj).length==0){
            return"";
          }
          const strings=Object.keys(obj).reduce((a,k)=>{
              if(obj[k]===null||obj[k]===undefined){

              }else if(Array.isArray(obj[k])){
                for(let i=0;i<obj[k].length;i++)
                {
                  a.push(encodeURIComponent(k)+'='+encodeURIComponent(obj[k][i]));
                  
                }
              }else{
                a.push(encodeURIComponent(k)+'='+encodeURIComponent(obj[k]));
              }
              return a;
            },[]);
          return'?'+strings.join('&');
        }
        function parseParameters(text=undefined){
          let match;
          let search=/([^&=]+)=?([^&]*)/g;
          let decode=s=>decodeURIComponent(s.replace(/\+/g," "));
          let search_term=(new URL(window.location.protocol+"//"+window.location.hostname+window.daedalus_location)).search;
          
          let query=(text===undefined)?search_term.substring(1):text;
          let urlParams={};
          while(match=search.exec(query)){
            let value=decode(match[2]);
            let key=decode(match[1]);
            if(urlParams[key]===undefined){
              urlParams[key]=[value];
            }else{
              urlParams[key].push(value);
            }
          }
          return urlParams;
        }
        function isFunction(x){
          return(x instanceof Function);
        }
        function joinpath(...parts){
          let str="";
          for(let i=0;i<parts.length;i++)
          {
            if(!str.endsWith("/")&&!parts[i].startsWith("/")){
              str+="/";
            }
            str+=parts[i];
          }
          return str;
        }
        function splitpath(path){
          const parts=path.split('/');
          if(parts.length>0&&parts[parts.length-1].length===0){
            parts.pop();
          }
          return parts;
        }
        function dirname(path){
          const parts=path.split('/');
          while(parts.length>0&&parts[parts.length-1].length===0){
            parts.pop();
          }
          return joinpath(...parts.slice(0,-1));
        }
        function splitext(name){
          const index=name.lastIndexOf('.');
          if(index<=0||name[index-1]=='/'){
            return[name,''];
          }else{
            return[name.slice(0,index),name.slice(index)];
          }
        }
        let css_sheet=null;
        let selector_names={};
        function generateStyleSheetName(){
          const chars='abcdefghijklmnopqrstuvwxyz';
          let name;
          do {
            name="css-";
            for(let i=0;i<6;i++)
            {
              let c=chars[randomInt(0,chars.length-1)];
              name+=c;
            }
          } while (name in selector_names)
          return name;
        }
        function shuffle(array){
          let currentIndex=array.length,temporaryValue,randomIndex;
          while(0!==currentIndex){
            randomIndex=Math.floor(Math.random()*currentIndex);
            currentIndex-=1;
            temporaryValue=array[currentIndex];
            array[currentIndex]=array[randomIndex];
            array[randomIndex]=temporaryValue;
          }
          return array;
        }
        function StyleSheet(...args){
          let name;
          let style;
          let selector;
          if(args.length===1){
            name=generateStyleSheetName();
            selector="."+name;
            style=args[0];
          }else if(args.length===2){
            selector=args[0];
            style=args[1];
            name=selector;
          }
          if(css_sheet===null){
            css_sheet=document.createElement('style');
            css_sheet.type='text/css';
            document.head.appendChild(css_sheet);
          }
          const text=object2style(style);
          selector_names[name]=style;
          css_sheet.sheet.insertRule(selector+" {"+text+"}",css_sheet.sheet.rules.length);
          
          return name;
        }
        function getStyleSheet(name){
          return selector_names[name];
        }
        function perf_timer(){
          return performance.now();
        }
        const util={array_move,randomInt,randomFloat,object2style,serializeParameters,
                  parseParameters,isFunction,joinpath,splitpath,dirname,splitext,shuffle,
                  perf_timer};
        return[StyleSheet,getStyleSheet,parseParameters,util];
      })();
    const[ButtonElement,DomElement,DraggableList,DraggableListItem,HeaderElement,
          LinkElement,ListElement,ListItemElement,TextElement,TextInputElement]=(function(
            ){
        let element_uid=0;
        function generateElementId(){
          const chars='abcdefghijklmnopqrstuvwxyz';
          let name;
          name="-";
          for(let i=0;i<6;i++)
          {
            let c=chars[util.randomInt(0,chars.length-1)];
            name+=c;
          }
          return name+"-"+(element_uid++);
        }
        class DomElement{
          constructor(type="div",props=undefined,children=undefined){
            if(type===undefined){
              throw`DomElement type is undefined. super called with ${arguments.length} arguments`;
              
            }
            this.type=type;
            this.props=props??{};
            this.children=children??[];
            if(this.props.id===undefined){
              this.props.id=this.constructor.name+generateElementId();
            }
            this._$dirty=true;
            this.state={};
            this.attrs={};
            this._$fiber=null;
            Object.getOwnPropertyNames(this.__proto__).filter(key=>key.startsWith(
                              "on")).forEach(key=>{
                this.props[key]=this[key].bind(this);
              });
          }
          _update(element,debug=false){

          }
          update(debug=false){
            this._update(this,debug);
          }
          updateState(state,doUpdate){
            const newState={...this.state,...state};
            if(doUpdate!==false){
              if((doUpdate===true)||(this.elementUpdateState===undefined)||(this.elementUpdateState(
                                      this.state,newState)!==false)){
                this.update();
              }
            }
            this.state=newState;
          }
          updateProps(props,doUpdate){
            const newProps={...this.props,...props};
            if(doUpdate!==false){
              if((doUpdate===true)||(this.elementUpdateProps===undefined)||(this.elementUpdateProps(
                                      this.props,newProps)!==false)){
                this.update();
              }
            }
            this.props=newProps;
          }
          appendChild(childElement){
            if(!childElement||!childElement.type){
              console.log({message:"invalid child",child:childElement});
              throw"appendChild Failed: child is null or type not set";
            }
            if(typeof this.children==="string"){
              this.children=[this.children];
            }else if(typeof this.children==="undefined"){
              this.children=[];
            }
            this.children.push(childElement);
            this.update();
            return childElement;
          }
          insertChild(index,childElement){
            if(!childElement||!childElement.type){
              throw"invalid child";
            }
            if(index<0){
              index+=this.children.length+1;
            }
            if(index<0||index>this.children.length){
              console.error("invalid index: "+index);
              return;
            }
            if(typeof this.children==="string"){
              this.children=[this.children];
            }else if(typeof this.children==="undefined"){
              this.children=[];
            }
            this.children.splice(index,0,childElement);
            this.update();
            return childElement;
          }
          removeChildAtIndex(index){
            if(index>=0){
              this.children.splice(index,1);
              this.update();
            }else{
              console.error("child not in list");
            }
          }
          removeChild(childElement){
            if(!childElement||!childElement.type){
              throw"invalid child";
            }
            this.removeChildAtIndex(this.children.indexOf(childElement));
          }
          removeChildren(){
            this.children.splice(0,this.children.length);
            this.update();
          }
          replaceChild(childElement,newChildElement){
            const index=this.children.indexOf(childElement);
            if(index>=0){
              this.children[index]=newChildElement;
              this.update();
            }
          }
          addClassName(cls){
            let props;
            if(this.props.className==undefined||this.props.className==null){
              props={className:cls};
            }else if(Array.isArray(this.props.className)){
              if(this.hasClassName(cls)){
                return;
              }
              props={className:[cls,...this.props.className]};
            }else{
              if(this.props.className===cls){
                return;
              }
              props={className:[cls,this.props.className]};
            }
            this.updateProps(props);
          }
          removeClassName(cls){
            let props;
            if(Array.isArray(this.props.className)){
              props={className:this.props.className.filter(x=>(x!==cls))};
              if(props.className.length===this.props.className.length){
                return;
              }
              this.updateProps(props);
            }else if(this.props.className===cls){
              props={className:null};
              this.updateProps(props);
            }
          }
          hasClassName(cls){
            let props;
            if(Array.isArray(this.props.className)){
              return this.props.className.filter(x=>x===cls).length>0;
            }
            return this.props.className===cls;
          }
          getDomNode(){
            if(this._$fiber==null){
              console.error(this);
            }
            return this._$fiber&&this._$fiber.dom;
          }
          isMounted(){
            return this._$fiber!==null;
          }
        }
        class TextElement extends DomElement {
          constructor(text,props={}){
            super("TEXT_ELEMENT",{'nodeValue':text,...props},[]);
          }
          setText(text){
            this.props={'nodeValue':text};
            this.update();
          }
          getText(){
            return this.props.nodeValue;
          }
        }
        class LinkElement extends DomElement {
          constructor(text,url){
            super("div",{className:LinkElement.style.link,title:url},[new TextElement(
                                  text)]);
            this.state={url};
          }
          onClick(){
            if(this.state.url.startsWith('http')){
              window.open(this.state.url,'_blank');
            }else{
              history.pushState({},"",this.state.url);
            }
          }
        }
        LinkElement.style={link:'dcs-16e24fb6-0'};
        class ListElement extends DomElement {
          constructor(){
            super("ul",{},[]);
          }
        }
        class ListItemElement extends DomElement {
          constructor(item){
            super("li",{},[item]);
          }
        }
        class HeaderElement extends DomElement {
          constructor(text=""){
            super("h1",{},[]);
            this.node=this.appendChild(new TextElement(text));
          }
          setText(text){
            this.node.setText(text);
          }
        }
        class ButtonElement extends DomElement {
          constructor(text,onClick){
            super("button",{'onClick':onClick},[new TextElement(text)]);
          }
          setText(text){
            this.children[0].setText(text);
          }
          getText(){
            return this.children[0].props.nodeValue;
          }
        }
        class TextInputElement extends DomElement {
          constructor(text,_,submit_callback){
            super("input",{value:text,type:"text"},[]);
            this.attrs={submit_callback};
          }
          setText(text){
            this.getDomNode().value=text;
          }
          getText(){
            return this.getDomNode().value;
          }
          onChange(event){

          }
          onPaste(event){

          }
          onKeyUp(event){
            if(event.key=="Enter"){
              if(this.attrs.submit_callback){
                this.attrs.submit_callback(this.getText());
              }
            }
          }
        }
        function swap(nodeA,nodeB){
          if(!nodeA||!nodeB){
            return;
          }
          const parentA=nodeA.parentNode;
          const siblingA=nodeA.nextSibling===nodeB?nodeA:nodeA.nextSibling;
          nodeB.parentNode.insertBefore(nodeA,nodeB);
          parentA.insertBefore(nodeB,siblingA);
        }
        function isAbove(nodeA,nodeB){
          if(!nodeA||!nodeB){
            return false;
          }
          const rectA=nodeA.getBoundingClientRect();
          const rectB=nodeB.getBoundingClientRect();
          const a=rectA.top+rectA.height/2;
          const b=rectB.top+rectB.height/2;
          return a<b;
        }
        function childIndex(node){
          if(node===null){
            return 0;
          }
          let count=0;
          while((node=node.previousSibling)!=null){
            count++;
          }
          return count;
        }
        const placeholder='dcs-16e24fb6-1';
        class DraggableListItem extends DomElement {
          constructor(){
            super("div",{},[]);
          }
          onTouchStart(event){
            this.attrs.parent.handleChildDragBegin(this,event);
          }
          onTouchMove(event){
            this.attrs.parent.handleChildDragMove(this,event);
          }
          onTouchEnd(event){
            this.attrs.parent.handleChildDragEnd(this,{target:this.getDomNode()});
            
          }
          onTouchCancel(event){
            this.attrs.parent.handleChildDragEnd(this,{target:this.getDomNode()});
            
          }
          onMouseDown(event){
            this.attrs.parent.handleChildDragBegin(this,event);
          }
          onMouseMove(event){
            this.attrs.parent.handleChildDragMove(this,event);
          }
          onMouseLeave(event){
            this.attrs.parent.handleChildDragEnd(this,event);
          }
          onMouseUp(event){
            this.attrs.parent.handleChildDragEnd(this,event);
          }
        }
        class DraggableList extends DomElement {
          constructor(){
            super("div",{},[]);
            this.attrs={x:null,y:null,placeholder:null,placeholderClassName:placeholder,
                          draggingEle:null,isDraggingStarted:false,indexStart:-1,lockX:true,swipeScrollTimer:null};
            
          }
          setPlaceholderClassName(className){
            this.attrs.placeholderClassName=className;
          }
          handleChildDragBegin(child,event){
            if(!!this.attrs.draggingEle){
              console.error("running drag cancel because previous did not finish");
              
              this.handleChildDragCancel();
            }
            let org_event=event;
            let evt=(((event)||{}).touches||((((event)||{}).originalEvent)||{}).touches);
            
            if(evt){
              event=evt[0];
            }
            this.attrs.draggingEle=child.getDomNode();
            if(!this.attrs.draggingEle){
              console.error("no element set for drag");
              return false;
            }
            this.attrs.draggingChild=child;
            this.attrs.indexStart=childIndex(this.attrs.draggingEle);
            if(this.attrs.indexStart<0){
              console.error("drag begin failed for child");
              this.attrs.draggingEle=null;
              this.attrs.indexStart=-1;
              return false;
            }
            const rect=this.attrs.draggingEle.getBoundingClientRect();
            this.attrs.x=event.clientX-rect.left;
            this.attrs.y=event.pageY+window.scrollY;
            this.attrs.eventSource=child;
            return true;
          }
          handleChildDragMoveImpl(pageX,pageY){
            const rect=this.attrs.draggingEle.parentNode.getBoundingClientRect();
            
            pageY-=rect.top+window.scrollY;
            const draggingRect=this.attrs.draggingEle.getBoundingClientRect();
            if(this.attrs.indexStart<0){
              console.error("drag move failed for child");
              return false;
            }
            if(!this.attrs.isDraggingStarted){
              this.attrs.isDraggingStarted=true;
              this.attrs.placeholder=document.createElement('div');
              this.attrs.placeholder.classList.add(this.attrs.placeholderClassName);
              
              this.attrs.draggingEle.parentNode.insertBefore(this.attrs.placeholder,
                              this.attrs.draggingEle.nextSibling);
              this.attrs.placeholder.style.height=`${this.attrs.draggingEle.clientHeight}px`;
              
            }
            this.attrs.draggingEle.style.position='absolute';
            let ypos=pageY-(this.attrs.draggingEle.clientHeight/2);
            this.attrs.draggingEle.style.top=`${ypos}px`;
            if(!this.attrs.lockX){
              this.attrs.draggingEle.style.left=`${pageX-this.attrs.x}px`;
            }
            const prevEle=this.attrs.draggingEle.previousElementSibling;
            const nextEle=this.attrs.placeholder.nextElementSibling;
            if(prevEle&&isAbove(this.attrs.draggingEle,prevEle)){
              swap(this.attrs.placeholder,this.attrs.draggingEle);
              swap(this.attrs.placeholder,prevEle);
              const a=childIndex(prevEle)-1;
              const b=childIndex(this.attrs.draggingEle);
              prevEle._$fiber.element.setIndex(a);
              this.attrs.draggingEle._$fiber.element.setIndex(b);
            }else if(nextEle&&isAbove(nextEle,this.attrs.draggingEle)){
              swap(nextEle,this.attrs.placeholder);
              swap(nextEle,this.attrs.draggingEle);
              const a=childIndex(nextEle);
              const b=childIndex(this.attrs.draggingEle);
              nextEle._$fiber.element.setIndex(a);
              this.attrs.draggingEle._$fiber.element.setIndex(b);
            }
            return true;
          }
          _handleAutoScroll(dy){
            const rate=15;
            const step=rate*dy;
            let _y=window.pageYOffset;
            window.scrollBy(0,step);
            if(_y!=window.pageYOffset){
              let total_step=window.pageYOffset-_y;
              this.attrs.y+=total_step;
              this.attrs.autoScrollY+=total_step;
              this.handleChildDragMoveImpl(this.attrs.autoScrollX,this.attrs.autoScrollY);
              
            }
          }
          _handleChildDragAutoScroll(evt){
            const _rect=this.attrs.draggingEle.parentNode.getBoundingClientRect();
            
            let node=this.getDomNode();
            const lstTop=window.scrollY+_rect.top;
            let top=window.scrollY+_rect.top;
            let bot=top+window.innerHeight-lstTop;
            let y=Math.floor(evt.pageY-node.offsetTop-window.scrollY);
            let h=this.attrs.draggingEle.clientHeight;
            if(y<top+h){
              this.attrs.autoScrollX=Math.floor(evt.pageX);
              this.attrs.autoScrollY=Math.floor(evt.pageY);
              if(this.attrs.swipeScrollTimer===null){
                this.attrs.swipeScrollTimer=setInterval(()=>{
                    this._handleAutoScroll(-1);
                  },33);
              }
            }else if(y>bot-h*2){
              this.attrs.autoScrollX=Math.floor(evt.pageX);
              this.attrs.autoScrollY=Math.floor(evt.pageY);
              if(this.attrs.swipeScrollTimer===null){
                this.attrs.swipeScrollTimer=setInterval(()=>{
                    this._handleAutoScroll(1);
                  },33);
              }
            }else if(this.attrs.swipeScrollTimer!==null){
              clearInterval(this.attrs.swipeScrollTimer);
              this.attrs.swipeScrollTimer=null;
            }
          }
          handleChildDragMove(child,event){
            if(!this.attrs.draggingEle){
              return false;
            }
            if(this.attrs.draggingEle!==child.getDomNode()){
              return false;
            }
            let org_event=event;
            let evt=(((event)||{}).touches||((((event)||{}).originalEvent)||{}).touches);
            
            if(evt){
              event=evt[0];
            }
            this._handleChildDragAutoScroll(event);
            let x=Math.floor(event.pageX);
            let y=Math.floor(event.pageY);
            if(this.attrs._px!==x||this.attrs._py!==y){
              this.attrs._px=x;
              this.attrs._py=y;
              return this.handleChildDragMoveImpl(x,y);
            }
          }
          handleChildDragEnd(child,event){
            return this.handleChildDragCancel();
          }
          handleChildDragCancel(doUpdate=true){
            this.attrs.placeholder&&this.attrs.placeholder.parentNode.removeChild(
                          this.attrs.placeholder);
            const indexEnd=childIndex(this.attrs.draggingEle);
            if(this.attrs.indexStart>=0&&this.attrs.indexStart!==indexEnd){
              this.updateModel(this.attrs.indexStart,indexEnd);
            }
            if(this.attrs.draggingEle){
              this.attrs.draggingEle.style.removeProperty('top');
              this.attrs.draggingEle.style.removeProperty('left');
              this.attrs.draggingEle.style.removeProperty('position');
            }
            if(this.attrs.swipeScrollTimer!==null){
              clearInterval(this.attrs.swipeScrollTimer);
              this.attrs.swipeScrollTimer=null;
            }
            const success=this.attrs.draggingEle!==null;
            this.attrs.x=null;
            this.attrs.y=null;
            this.attrs.draggingEle=null;
            this.attrs.isDraggingStarted=false;
            this.attrs.placeholder=null;
            this.attrs.indexStart=-1;
            return success;
          }
          updateModel(indexStart,indexEnd){
            this.children.splice(indexEnd,0,this.children.splice(indexStart,1)[0]);
            
          }
          debugString(){
            let str="";
            if(this.attrs.isDraggingStarted){
              str+=" dragging";
            }else{
              str+=" not dragging";
            }
            if(this.attrs.draggingEle){
              str+='elem';
            }
            if(this.attrs.x||this.attrs.y){
              str+=` x:${this.attrs.x}, y:${this.attrs.y}`;
            }
            return str;
          }
        }
        return[ButtonElement,DomElement,DraggableList,DraggableListItem,HeaderElement,
                  LinkElement,ListElement,ListItemElement,TextElement,TextInputElement];
      })();
    const[]=(function(){
        if(location){
          window.daedalus_location=location.pathname+location.search+location.hash;
          
        }
        function _sendEvent(path){
          const myEvent=new CustomEvent('locationChangedEvent',{detail:{path:path},
                          bubbles:true,cancelable:true,composed:false});
          window.daedalus_location=path;
          window.dispatchEvent(myEvent);
        }
        history._pushState=history.pushState;
        history.pushState=(state,title,path)=>{
          history._pushState(state,title,path);
          _sendEvent(path);
        };
        window.addEventListener('popstate',(event)=>{
            _sendEvent(location.pathname+location.search+location.hash);
          });
        return[];
      })();
    const[AuthenticatedRouter,Router,locationMatch,patternCompile,patternToRegexp]=(
          function(){
        function patternCompile(pattern){
          const arr=pattern.split('/');
          let tokens=[];
          for(let i=1;i<arr.length;i++)
          {
            let part=arr[i];
            if(part.startsWith(':')){
              if(part.endsWith('?')){
                tokens.push({param:true,name:part.substr(1,part.length-2)});
              }else if(part.endsWith('+')){
                tokens.push({param:true,name:part.substr(1,part.length-2)});
              }else if(part.endsWith('*')){
                tokens.push({param:true,name:part.substr(1,part.length-2)});
              }else{
                tokens.push({param:true,name:part.substr(1)});
              }
            }else{
              tokens.push({param:false,value:part});
            }
          }
          return(items,query_items)=>{
            let location='';
            for(let i=0;i<tokens.length;i++)
            {
              location+='/';
              if(tokens[i].param){
                location+=items[tokens[i].name];
              }else{
                location+=tokens[i].value;
              }
            }
            if(!!query_items){
              location+=util.serializeParameters(query_items);
            }
            return location;
          };
        }
        function patternToRegexp(pattern,exact=true){
          const arr=pattern.split('/');
          let re="^";
          let tokens=[];
          for(let i=exact?1:0;i<arr.length;i++)
          {
            let part=arr[i];
            if(i==0&&exact===false){

            }else{
              re+="\\/";
            }
            if(part.startsWith(':')){
              if(part.endsWith('?')){
                tokens.push(part.substr(1,part.length-2));
                re+="([^\\/]*)";
              }else if(part.endsWith('+')){
                tokens.push(part.substr(1,part.length-2));
                re+="?(.+)";
              }else if(part.endsWith('*')){
                tokens.push(part.substr(1,part.length-2));
                re+="?(.*)";
              }else{
                tokens.push(part.substr(1));
                re+="([^\\/]+)";
              }
            }else{
              re+=part;
            }
          }
          if(re!=="^\\/"){
            re+="\\/?";
          }
          re+="$";
          return{re:new RegExp(re,"i"),text:re,tokens};
        }
        function locationMatch(obj,location){
          obj.re.lastIndex=0;
          let arr=location.match(obj.re);
          if(arr==null){
            return null;
          }
          let result={};
          for(let i=1;i<arr.length;i++)
          {
            result[obj.tokens[i-1]]=arr[i];
          }
          return result;
        }
        function patternMatch(pattern,location){
          return locationMatch(patternToRegexp(pattern),location);
        }
        class Router{
          constructor(container,default_callback){
            if(!container){
              throw'invalid container';
            }
            this.container=container;
            this.default_callback=default_callback;
            this.routes=[];
            this.current_index=-2;
            this.current_location=null;
            this.match=null;
          }
          handleLocationChanged(location){
            let auth=this.isAuthenticated();
            let index=0;
            while(index<this.routes.length){
              const item=this.routes[index];
              if(!auth&&item.auth){
                index+=1;
                continue;
              }
              const match=locationMatch(item.re,(new URL(window.location.protocol+"//"+window.location.hostname+location)).pathname);
              
              if(match!==null){
                let fn=(element)=>this.setElement(index,location,match,element);
                if(this.doRoute(item,fn,match)){
                  return;
                }
              }
              index+=1;
            }
            let fn=(element)=>this.setElement(-1,location,null,element);
            this.default_callback(fn);
            return;
          }
          doRoute(item,fn,match){
            item.callback(fn,match);
            return true;
          }
          setElement(index,location,match,element){
            if(!!element){
              if(index!=this.current_index){
                this.container.children=[element];
                this.container.update();
              }
              if(this.current_location!==location){
                this.setMatch(match);
                element.updateState({match:match});
              }
              this.current_index=index;
            }else{
              this.container.children=[];
              this.current_index=-1;
              this.container.update();
            }
            this.current_location=location;
          }
          addRoute(pattern,callback){
            const re=patternToRegexp(pattern);
            this.routes.push({pattern,callback,re});
          }
          setDefaultRoute(callback){
            this.default_callback=callback;
          }
          setMatch(match){
            this.match=match;
          }
          clear(){
            this.container.children=[];
            this.current_index=-1;
            this.current_location=null;
            this.container.update();
          }
          isAuthenticated(){
            return false;
          }
        }
        Router.instance=null;
        class AuthenticatedRouter extends Router {
          constructor(container,route_list,default_callback){
            super(container,route_list,default_callback);
            this.authenticated=false;
          }
          doRoute(item,fn,match){
            let has_auth=this.isAuthenticated();
            if(item.auth===true&&item.noauth===undefined){
              if(!!has_auth){
                item.callback(fn,match);
                return true;
              }else if(item.fallback!==undefined){
                history.pushState({},"",item.fallback);
                return true;
              }
            }
            if(item.auth===undefined&&item.noauth===true){
              if(!has_auth){
                item.callback(fn,match);
                return true;
              }else if(item.fallback!==undefined){
                history.pushState({},"",item.fallback);
                return true;
              }
            }
            if(item.auth===undefined&&item.noauth===undefined){
              item.callback(fn,match);
              return true;
            }
            return false;
          }
          isAuthenticated(){
            return this.authenticated;
          }
          setAuthenticated(value){
            this.authenticated=!!value;
          }
          addAuthRoute(pattern,callback,fallback){
            const re=patternToRegexp(pattern);
            this.routes.push({pattern,callback,auth:true,fallback,re});
          }
          addNoAuthRoute(pattern,callback,fallback){
            const re=patternToRegexp(pattern);
            this.routes.push({pattern,callback,noauth:true,fallback,re});
          }
        }
        return[AuthenticatedRouter,Router,locationMatch,patternCompile,patternToRegexp];
        
      })();
    const[downloadFile,uploadFile]=(function(){
        function saveBlob(blob,fileName){
          let a=document.createElement('a');
          a.href=window.URL.createObjectURL(blob);
          a.download=fileName;
          a.dispatchEvent(new MouseEvent('click'));
        }
        function downloadFile(url,headers={},params={},success=null,failure=null){
        
          const postData=new FormData();
          const queryString=util.serializeParameters(params);
          const xhr=new XMLHttpRequest();
          xhr.open('GET',url+queryString);
          for(let key in headers){
            xhr.setRequestHeader(key,headers[key]);
          }
          xhr.responseType='blob';
          xhr.onload=function(this_,event_){
            let blob=this_.target.response;
            if(!blob||this_.target.status!=200){
              if(failure!==null){
                failure({status:this_.target.status,blob});
              }
            }else{
              let contentDispo=xhr.getResponseHeader('Content-Disposition');
              console.log(xhr);
              let fileName;
              if(contentDispo!==null){
                fileName=contentDispo.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/)[
                                1];
              }
              if(!fileName){
                console.error("filename not found in xhr request header 'Content-Disposition'");
                
                let parts;
                parts=xhr.responseURL.split('/');
                parts=parts[parts.length-1].split('?');
                fileName=parts[0]||'resource.bin';
              }
              saveBlob(blob,fileName);
              if(success!==null){
                success({url,fileName,blob});
              }
            }
          };
          xhr.send(postData);
        }
        function _uploadFileImpl(elem,urlbase,headers={},params={},success=null,failure=null,
                  progress=null){
          let queryString=util.serializeParameters(params);
          let arrayLength=elem.files.length;
          for(let i=0;i<arrayLength;i++)
          {
            let file=elem.files[i];
            let bytesTransfered=0;
            let url;
            if(urlbase.endsWith('/')){
              url=urlbase+file.name;
            }else{
              url=urlbase+'/'+file.name;
            }
            url+=queryString;
            let xhr=new XMLHttpRequest();
            xhr.open('POST',url,true);
            for(let key in headers){
              xhr.setRequestHeader(key,headers[key]);
            }
            xhr.upload.onprogress=function(event){
              if(event.lengthComputable){
                if(progress!==null){
                  bytesTransfered=event.loaded;
                  progress({bytesTransfered,fileSize:file.size,fileName:file.name,
                                          finished:false});
                }
              }
            };
            xhr.onreadystatechange=function(){
              if(xhr.readyState==4&&xhr.status==200){
                if(success!==null){
                  let params={fileName:file.name,url,lastModified:file.lastModified,
                                      size:file.size,type:file.type};
                  success(params);
                  if(progress!==null){
                    progress({bytesTransfered:file.size,fileSize:file.size,fileName:file.name,
                                              finished:true});
                  }
                }
              }else if(xhr.status>=400){
                if(failure!==null){
                  let params={fileName:file.name,url,status:xhr.status};
                  failure(params);
                  if(progress!==null){
                    progress({bytesTransfered,fileSize:file.size,fileName:file.name,
                                              finished:true});
                  }
                }
              }else{
                console.log("xhr status changed: "+xhr.status);
              }
            };
            if(progress!==null){
              progress({bytesTransfered,fileSize:file.size,fileName:file.name,finished:false,
                                  first:true});
            }
            let fd=new FormData();
            fd.append('upload',file);
            xhr.send(fd);
          }
        }
        function uploadFile(urlbase,headers={},params={},success=null,failure=null,
                  progress=null){
          let element=document.createElement('input');
          element.type='file';
          element.hidden=true;
          element.onchange=(event)=>{
            _uploadFileImpl(element,urlbase,headers,params,success,failure,progress);
            
          };
          element.dispatchEvent(new MouseEvent('click'));
        }
        return[downloadFile,uploadFile];
      })();
    const[OSName,platform]=(function(){
        let nVer=navigator.appVersion;
        let nAgt=navigator.userAgent;
        let browserName=navigator.appName;
        let fullVersion=''+parseFloat(navigator.appVersion);
        let majorVersion=parseInt(navigator.appVersion,10);
        let nameOffset,verOffset,ix;
        if((verOffset=nAgt.indexOf("Opera"))!=-1){
          browserName="Opera";
          fullVersion=nAgt.substring(verOffset+6);
          if((verOffset=nAgt.indexOf("Version"))!=-1){
            fullVersion=nAgt.substring(verOffset+8);
          }
        }else if((verOffset=nAgt.indexOf("MSIE"))!=-1){
          browserName="Microsoft Internet Explorer";
          fullVersion=nAgt.substring(verOffset+5);
        }else if((verOffset=nAgt.indexOf("Chrome"))!=-1){
          browserName="Chrome";
          fullVersion=nAgt.substring(verOffset+7);
        }else if((verOffset=nAgt.indexOf("Safari"))!=-1){
          browserName="Safari";
          fullVersion=nAgt.substring(verOffset+7);
          if((verOffset=nAgt.indexOf("Version"))!=-1){
            fullVersion=nAgt.substring(verOffset+8);
          }
        }else if((verOffset=nAgt.indexOf("Firefox"))!=-1){
          browserName="Firefox";
          fullVersion=nAgt.substring(verOffset+8);
        }else if((nameOffset=nAgt.lastIndexOf(' ')+1)<(verOffset=nAgt.lastIndexOf(
                          '/'))){
          browserName=nAgt.substring(nameOffset,verOffset);
          fullVersion=nAgt.substring(verOffset+1);
          if(browserName.toLowerCase()==browserName.toUpperCase()){
            browserName=navigator.appName;
          }
        }
        if((ix=fullVersion.indexOf(";"))!=-1){
          fullVersion=fullVersion.substring(0,ix);
        }
        if((ix=fullVersion.indexOf(" "))!=-1){
          fullVersion=fullVersion.substring(0,ix);
        }
        majorVersion=parseInt(''+fullVersion,10);
        if(isNaN(majorVersion)){
          fullVersion=''+parseFloat(navigator.appVersion);
          majorVersion=parseInt(navigator.appVersion,10);
        }
        let OSName="Unknown OS";
        if(navigator.appVersion.indexOf("Win")!=-1){
          OSName="Windows";
        }
        if(navigator.appVersion.indexOf("Mac")!=-1){
          OSName="MacOS";
        }
        if(navigator.appVersion.indexOf("X11")!=-1){
          OSName="UNIX";
        }
        if(navigator.appVersion.indexOf("Linux")!=-1){
          OSName="Linux";
        }
        function getDefaultFontSize(parentElement){
          parentElement=parentElement||document.body;
          let div=document.createElement('div');
          div.style.width="1000em";
          parentElement.appendChild(div);
          let pixels=div.offsetWidth/1000;
          parentElement.removeChild(div);
          return pixels;
        }
        const isMobile={Android:function(){
            return navigator.userAgent.match(/Android/i);
          },BlackBerry:function(){
            return navigator.userAgent.match(/BlackBerry/i);
          },iOS:function(){
            return navigator.userAgent.match(/iPhone|iPad|iPod/i);
          },Opera:function(){
            return navigator.userAgent.match(/Opera Mini/i);
          },Windows:function(){
            return navigator.userAgent.match(/IEMobile/i)||navigator.userAgent.match(
                          /WPDesktop/i);
          },any:function(){
            return(isMobile.Android()||isMobile.BlackBerry()||isMobile.iOS()||isMobile.Opera(
                            )||isMobile.Windows());
          }};
        const platform={OSName,browser:browserName,fullVersion,majorVersion,appName:navigator.appName,
                  userAgent:navigator.userAgent,platform:build_platform||'web',isAndroid:build_platform==='android',
                  isQt:build_platform==='qt',isMobile:(!!isMobile.any())};
        return[OSName,platform];
      })();
    const[render,render_update]=(function(){
        if(window.requestIdleCallback===undefined){
          window.requestIdleCallback=(callback,options)=>{
            setTimeout(()=>{
                callback();
              },0);
          };
        }
        let workstack=[];
        let deletions=[];
        let deletions_removed=new Set();
        let updatequeue=[];
        let wipRoot=null;
        let currentRoot=null;
        let workLoopActive=false;
        let workCounter=0;
        function render(container,element){
          wipRoot={type:"ROOT",dom:container,props:{},children:[element],_fibers:[
                        ],alternate:currentRoot};
          workstack.push(wipRoot);
          if(!workLoopActive){
            workLoopActive=true;
            setTimeout(workLoop,0);
          }
        }
        function render_update(element,debug=false){
          if(!element._$dirty&&element._$fiber!==null){
            element._$dirty=true;
            const fiber={effect:'UPDATE',children:[element],_fibers:[],alternate:null,
                          partial:true,debug:debug};
            updatequeue.push(fiber);
          }
          if(!workLoopActive){
            workLoopActive=true;
            setTimeout(workLoop,0);
          }
        }
        DomElement.prototype._update=render_update;
        function workLoop(deadline=null){
          let shouldYield=false;
          const initialWorkLength=workstack.length;
          const initialUpdateLength=updatequeue.length;
          let friendly=deadline!=null;
          let initial_delay=0;
          try{
            if(!!friendly){
              initial_delay=deadline.timeRemaining();
              while(!shouldYield){
                while(workstack.length>0&&!shouldYield){
                  let unit=workstack.pop();
                  performUnitOfWork(unit);
                  shouldYield=deadline.timeRemaining()<1;
                }
                if(workstack.length==0&&wipRoot){
                  commitRoot();
                }
                if(workstack.length==0&&updatequeue.length>0&&!wipRoot){
                  wipRoot=updatequeue[0];
                  workstack.push(wipRoot);
                  updatequeue.shift();
                }
                shouldYield=deadline.timeRemaining()<1;
              }
            }else{
              while(1){
                while(workstack.length>0){
                  let unit=workstack.pop();
                  performUnitOfWork(unit);
                }
                if(wipRoot){
                  commitRoot();
                }
                if(updatequeue.length>0&&!wipRoot){
                  wipRoot=updatequeue[0];
                  workstack.push(wipRoot);
                  updatequeue.shift();
                }else{
                  break;
                }
              }
            }
          }catch(e){
            console.error("unhandled workloop exception: "+e.message);
          };
          let debug=workstack.length>1||updatequeue.length>1;
          if(!!debug){
            console.warn("workloop failed to finish",initial_delay,":",initialWorkLength,
                          '->',workstack.length,initialUpdateLength,'->',updatequeue.length);
            
            if(!friendly){
              setTimeout(workLoop,50);
            }else{
              requestIdleCallback(workLoop);
            }
          }else{
            workLoopActive=false;
          }
        }
        function performUnitOfWork(fiber){
          if(!fiber.dom&&fiber.effect=='CREATE'){
            fiber.dom=createDomNode(fiber);
          }
          reconcileChildren(fiber);
        }
        function reconcileChildren(parentFiber){
          workCounter+=1;
          const oldParentFiber=parentFiber.alternate;
          if(!!oldParentFiber){
            oldParentFiber.children.forEach(child=>{
                child._delete=true;
              });
          }
          if(parentFiber.debug){
            console.log("do reconcileChildren");
          }
          let prev=parentFiber;
          while(prev.next){
            prev=prev.next;
          }
          let children_out_of_order=false;
          parentFiber.children.forEach((element,index)=>{
              if(!element||!element.type){
                console.error(`${parentFiber.element.props.id}: undefined child element at index ${index} `);
                
                return;
              }
              const oldFiber=element._$fiber;
              element._delete=false;
              const oldIndex=oldFiber?oldFiber.index:index;
              if(parentFiber.partial){
                index=oldIndex;
              }
              let effect;
              if(!!oldFiber){
                if(oldIndex==index&&element._$dirty===false){
                  return;
                }else{
                  effect='UPDATE';
                }
              }else{
                effect='CREATE';
              }
              element._$dirty=false;
              const newFiber={type:element.type,effect:effect,props:{...element.props},
                              children:element.children.slice(),_fibers:[],parent:(parentFiber.partial&&oldFiber)?oldFiber.parent:parentFiber,
                              alternate:oldFiber,dom:oldFiber?oldFiber.dom:null,element:element,
                              index:index,oldIndex:oldIndex,debug:((parentFiber)||{}).debug};
              if(index!==oldIndex){
                children_out_of_order=true;
              }
              if(!newFiber.parent.dom){
                console.error(`element parent is not mounted id: ${element.props.id} effect: ${effect}`);
                
                return;
              }
              if(newFiber.props.style){
                console.warn("unsafe use of inline style: ",newFiber.type,element.props.id,
                                  newFiber.props.style);
              }
              if(typeof(newFiber.props.style)==='object'){
                newFiber.props.style=util.object2style(newFiber.props.style);
              }
              if(Array.isArray(newFiber.props.className)){
                newFiber.props.className=newFiber.props.className.join(' ');
              }
              element._$fiber=newFiber;
              parentFiber._fibers.push(newFiber);
              prev.next=newFiber;
              prev=newFiber;
              workstack.push(newFiber);
            });
          if(children_out_of_order===true){
            const newFiber={type:parentFiber.type,effect:"SORT_CHILDREN",props:parentFiber.props,
                          children:parentFiber.children.slice(),_fibers:[],parent:parentFiber.parent,
                          dom:parentFiber.dom,debug:parentFiber.debug};
            prev.next=newFiber;
            prev=newFiber;
            workstack.push(newFiber);
          }
          if(!!oldParentFiber){
            oldParentFiber.children.forEach(child=>{
                if(child._delete){
                  deletions.push(child._$fiber);
                }
              });
          }
        }
        function commitRoot(){
          deletions_removed=new Set();
          deletions.forEach(removeDomNode);
          if(deletions_removed.size>0){
            deletions_removed.forEach(elem=>{
                requestIdleCallback(elem.elementUnmounted.bind(elem));
              });
          }
          let unit=wipRoot.next;
          let next;
          while(unit){
            commitWork(unit);
            next=unit.next;
            unit.next=null;
            unit=next;
          }
          currentRoot=wipRoot;
          wipRoot=null;
          deletions=[];
        }
        function commitWork(fiber){
          const parentDom=fiber.parent.dom;
          if(!parentDom){
            console.warn(`element has no parent. effect: ${fiber.effect}`);
            return;
          }
          if(((fiber)||{}).debug){
            console.log("commitWork: "+fiber.effect);
          }
          if(fiber.effect==='CREATE'){
            const length=parentDom.children.length;
            const position=fiber.index;
            if(length==position){
              parentDom.appendChild(fiber.dom);
            }else{
              parentDom.insertBefore(fiber.dom,parentDom.children[position]);
            }
            if(fiber.element.elementMounted){
              requestIdleCallback(fiber.element.elementMounted.bind(fiber.element));
              
            }
          }else if(fiber.effect==='UPDATE'){
            fiber.alternate.alternate=null;
            updateDomNode(fiber);
          }else if(fiber.effect==='DELETE'){
            fiber.alternate.alternate=null;
            removeDomNode(fiber);
          }else if(fiber.effect==='SORT_CHILDREN'){
            Array.from(fiber.dom.childNodes).forEach((node,idx)=>{
                let expected_index=node._$fiber.index;
                if(node._$fiber.index!==idx){
                  fiber.dom.removeChild(node);
                  fiber.dom.insertBefore(node,fiber.dom.children[expected_index]);
                  
                }
              });
          }
        }
        const isEvent=key=>key.startsWith("on");
        const isProp=key=>!isEvent(key);
        const isCreate=(prev,next)=>key=>(key in next&&!(key in prev));
        const isUpdate=(prev,next)=>key=>(key in prev&&key in next&&prev[key]!==next[
                    key]);
        const isDelete=(prev,next)=>key=>!(key in next);
        function createDomNode(fiber){
          const dom=fiber.type=="TEXT_ELEMENT"?document.createTextNode(""):document.createElement(
                      fiber.type);
          Object.keys(fiber.props).filter(isEvent).forEach(key=>{
              const event=key.toLowerCase().substring(2);
              dom.addEventListener(event,fiber.props[key]);
            });
          Object.keys(fiber.props).filter(isProp).forEach(key=>{
              const propValue=fiber.props[key];
              if(propValue===null){
                delete dom[key];
              }else{
                dom[key]=propValue;
              }
            });
          dom._$fiber=fiber;
          return dom;
        }
        function updateDomNode(fiber){
          const dom=fiber.dom;
          const parentDom=fiber.parent.dom;
          const oldProps=fiber.alternate.props;
          const newProps=fiber.props;
          if(!dom){
            console.log("fiber does not contain a dom");
            return;
          }
          dom._$fiber=fiber;
          if(fiber.debug){
            console.log("update",fiber.oldIndex,fiber.index);
          }
          if(fiber.oldIndex!=fiber.index&&parentDom){
            if(parentDom.children[fiber.index]!==dom){
              parentDom.removeChild(fiber.dom);
              parentDom.insertBefore(fiber.dom,parentDom.children[fiber.index]);
            }
          }
          Object.keys(oldProps).filter(isEvent).filter(key=>isUpdate(oldProps,newProps)(
                          key)||isDelete(oldProps,newProps)(key)).forEach(key=>{
              const event=key.toLowerCase().substring(2);
              dom.removeEventListener(event,oldProps[key]);
            });
          Object.keys(newProps).filter(isEvent).filter(key=>isCreate(oldProps,newProps)(
                          key)||isUpdate(oldProps,newProps)(key)).forEach(key=>{
              const event=key.toLowerCase().substring(2);
              dom.addEventListener(event,newProps[key]);
            });
          Object.keys(oldProps).filter(isProp).filter(isDelete(oldProps,newProps)).forEach(
                      key=>{
              dom[key]="";
            });
          Object.keys(newProps).filter(isProp).filter(key=>isCreate(oldProps,newProps)(
                          key)||isUpdate(oldProps,newProps)(key)).forEach(key=>{
              dom[key]=newProps[key];
            });
        }
        function _removeDomNode_elementFixUp(element){
          if(element.elementUnmounted){
            deletions_removed.add(element);
          }
          element.children.forEach(child=>{
              child._$fiber=null;
              _removeDomNode_elementFixUp(child);
            });
        }
        function removeDomNode(fiber){
          if(fiber.dom){
            if(fiber.dom.parentNode){
              fiber.dom.parentNode.removeChild(fiber.dom);
            }
          }else{
            console.error("failed to delete",fiber.element.type);
          }
          fiber.dom=null;
          fiber.element._$fiber=null;
          fiber.alternate=null;
          _removeDomNode_elementFixUp(fiber.element);
        }
        return[render,render_update];
      })();
    return{AuthenticatedRouter,ButtonElement,DomElement,DraggableList,DraggableListItem,
          HeaderElement,LinkElement,ListElement,ListItemElement,OSName,Router,StyleSheet,
          TextElement,TextInputElement,build_platform,downloadFile,env,getStyleSheet,
          locationMatch,parseParameters,patternCompile,patternToRegexp,platform,render,
          render_update,uploadFile,util};
  })();
engine=(function(daedalus){
    "use strict";
    const StyleSheet=daedalus.StyleSheet;
    const DomElement=daedalus.DomElement;
    const TextElement=daedalus.TextElement;
    const ListItemElement=daedalus.ListItemElement;
    const ListElement=daedalus.ListElement;
    const HeaderElement=daedalus.HeaderElement;
    const ButtonElement=daedalus.ButtonElement;
    const LinkElement=daedalus.LinkElement;
    const[Direction,Rect,randomChoice,randomNumber,randomRange,shuffle]=(function(
            ){
        function randomNumber(min,max){
          return Math.round(Math.random()*(max-min)+min);
        }
        function randomRange(min,max){
          return randomNumber(min,max-1);
        }
        function randomChoice(lst){
          if(lst.length==0){
            return null;
          }
          let i=randomRange(0,lst.length);
          return lst[i];
        }
        function shuffle(array){
          let currentIndex=array.length,randomIndex;
          while(currentIndex!=0){
            randomIndex=Math.floor(Math.random()*currentIndex);
            currentIndex--;
            [array[currentIndex],array[randomIndex]]=[array[randomIndex],array[currentIndex]];
            
          }
          return array;
        }
        const Direction={NONE:0,LEFT:1,RIGHT:2,UP:4,DOWN:8,UPLEFT:5,UPRIGHT:6,DOWNLEFT:9,
                  DOWNRIGHT:10,UPDOWN:12,LEFTRIGHT:3,ALL:15};
        Direction.name=Object.fromEntries(Object.entries(Direction).map(([key,value])=>[
                          value,key]));
        Direction.order=[Direction.RIGHT,Direction.UPRIGHT,Direction.UP,Direction.UPLEFT,
                  Direction.LEFT,Direction.DOWNLEFT,Direction.DOWN,Direction.DOWNRIGHT];
        Direction.flip={[Direction.UP]:Direction.DOWN,[Direction.UPRIGHT]:Direction.DOWNLEFT,
                  [Direction.RIGHT]:Direction.LEFT,[Direction.DOWNRIGHT]:Direction.UPLEFT,
                  [Direction.DOWN]:Direction.UP,[Direction.DOWNLEFT]:Direction.UPRIGHT,[Direction.LEFT]:Direction.RIGHT,
                  [Direction.UPLEFT]:Direction.DOWNRIGHT};
        Direction.fromVector=function(x,y){
          if(x==0&&y==0){
            return 0;
          }
          const theta=Math.atan2(y,-x)*180/Math.PI;
          let index=4+Math.round(theta/45);
          if(index==8){
            index=0;
          }
          return Direction.order[index];
        };
        Direction.vector=function(d){
          let xspeed=0;
          let yspeed=0;
          if(d&Direction.LEFT){
            xspeed=-1;
          }
          if(d&Direction.RIGHT){
            xspeed=1;
          }
          if(d&Direction.UP){
            yspeed=-1;
          }
          if(d&Direction.DOWN){
            yspeed=1;
          }
          return{x:xspeed,y:yspeed};
        };
        class Rect{
          constructor(x,y,w,h){
            this.x=x;
            this.y=y;
            this.w=w;
            this.h=h;
          }
          cx(){
            return Math.floor(this.x+this.w/2);
          }
          cy(){
            return Math.floor(this.y+this.h/2);
          }
          top(){
            return this.y;
          }
          right(){
            return this.x+this.w;
          }
          bottom(){
            return this.y+this.h;
          }
          left(){
            return this.x;
          }
          intersect(other){
            let l1=this.x;
            let l2=other.x;
            let r1=this.x+this.w;
            let r2=other.x+other.w;
            let t1=this.y;
            let t2=other.y;
            let b1=this.y+this.h;
            let b2=other.y+other.h;
            let l3=Math.max(l1,l2);
            let r3=Math.min(r1,r2);
            let t3=Math.max(t1,t2);
            let b3=Math.min(b1,b2);
            if(r3>l3&&b3>t3){
              return new Rect(l3,t3,r3-l3,b3-t3);
            }else{
              return new Rect(0,0,0,0);
            }
          }
          collideRect(other){
            let l1=this.x;
            let l2=other.x;
            let r1=this.x+this.w;
            let r2=other.x+other.w;
            let t1=this.y;
            let t2=other.y;
            let b1=this.y+this.h;
            let b2=other.y+other.h;
            return Math.max(l1,l2)<Math.min(r1,r2)&&Math.max(t1,t2)<Math.min(b1,b2);
            
          }
          collidePoint(x,y){
            let l1=this.x;
            let r1=this.x+this.w;
            let t1=this.y;
            let b1=this.y+this.h;
            return l1<=x&&x<r1&&t1<=y&&y<b1;
          }
        }
        return[Direction,Rect,randomChoice,randomNumber,randomRange,shuffle];
      })();
    const[ResourceLoader,SoundEffect,SoundEffectBuilder,SpriteSheet,SpriteSheetBuilder,
          SpriteTile]=(function(){
        class SoundEffect{
          constructor(path){
            let sound=new Audio();
            sound.src=path;
            this.ready=true;
            this.sounds=[sound,sound.cloneNode(),sound.cloneNode()];
            this.index=0;
          }
          play(){
            this.sounds[this.index].play().catch(error=>{
                console.log(error);
              });
            this.index=(this.index+1)%this.sounds.length;
          }
        }
        class SoundEffectBuilder{
          constructor(){
            this._path="";
          }
          path(path){
            this._path=path;
            return this;
          }
          build(){
            let se=new SoundEffect(this._path);
            return se;
          }
        }
        class SpriteSheetBuilder{
          constructor(){
            this._path="";
            this._tw=32;
            this._th=32;
            this._rows=1;
            this._cols=1;
            this._xspacing=0;
            this._yspacing=0;
            this._xoffset=0;
            this._yoffset=0;
          }
          path(path){
            this._path=path;
            return this;
          }
          dimensions(tw,th){
            this._tw=tw;
            this._th=th;
            return this;
          }
          layout(rows,cols){
            this._rows=rows;
            this._cols=cols;
            return this;
          }
          offset(x,y){
            this._xoffset=x;
            this._yoffset=y;
            return this;
          }
          spacing(x,y){
            this._xspacing=x;
            this._yspacing=y;
            return this;
          }
          build(){
            let ss=new SpriteSheet(this._path);
            ss.tw=this._tw;
            ss.th=this._th;
            ss.rows=this._rows;
            ss.cols=this._cols;
            ss.xspacing=this._xspacing;
            ss.yspacing=this._yspacing;
            ss.xoffset=this._xoffset;
            ss.yoffset=this._yoffset;
            return ss;
          }
        }
        class SpriteSheet{
          constructor(path){
            this.image=new Image();
            this.ready=false;
            this.image.onload=()=>{
              this.ready=true;
            };
            this.image.src=path;
            this.tw=0;
            this.th=0;
            this.rows=0;
            this.cols=0;
            this.xspacing=0;
            this.yspacing=0;
            this.xoffset=0;
            this.yoffset=0;
          }
          drawTile(ctx,tid,dx,dy){
            dx=Math.floor(dx);
            dy=Math.floor(dy);
            let sx=Math.floor((tid%this.cols)*(this.tw+this.xspacing)+this.xoffset);
            
            let sy=Math.floor(Math.floor(tid/this.cols)*(this.th+this.yspacing)+this.yoffset);
            
            ctx.drawImage(this.image,sx,sy,this.tw,this.th,dx,dy,this.tw,this.th);
            
          }
          drawTileScaled(ctx,tid,dx,dy,dw,dh){
            dx=Math.floor(dx);
            dy=Math.floor(dy);
            dw=Math.floor(dw);
            dh=Math.floor(dh);
            let sx=Math.floor((tid%this.cols)*(this.tw+this.xspacing)+this.xoffset);
            
            let sy=Math.floor(Math.floor(tid/this.cols)*(this.th+this.yspacing)+this.yoffset);
            
            ctx.drawImage(this.image,sx,sy,this.tw,this.th,dx,dy,dw,dh);
          }
          tile(tid){
            return new SpriteTile(this,tid);
          }
        }
        class SpriteTile{
          constructor(sheet,tid){
            this.sheet=sheet;
            this.tid=tid;
          }
          draw(ctx,dx,dy){
            this.sheet.drawTile(ctx,this.tid,dx,dy);
          }
        }
        class ResourceLoader{
          constructor(){
            this.resources=[];
            this.resource_count=0;
            this.ready=false;
            this.music={};
            this.sounds={};
            this.sheets={};
          }
          addSoundEffect(resid){
            let builder=new SoundEffectBuilder();
            this.resources.push({resid,builder,instance:null,kind:"sounds"});
            this.resource_count+=1;
            return builder;
          }
          addMusic(resid){
            return null;
          }
          addSpriteSheet(resid){
            let builder=new SpriteSheetBuilder();
            this.resources.push({resid,builder,instance:null,kind:"sheets"});
            this.resource_count+=1;
            return builder;
          }
          update(dt){
            if(this.ready){
              return;
            }
            for(let i=this.resources.length-1;i>=0;i--)
            {
              let res=this.resources[i];
              if(res.instance===null){
                res.instance=res.builder.build();
              }else if(res.instance.ready){
                if(res.kind=="sheets"){
                  this.sheets[res.resid]=res.instance;
                }
                if(res.kind=="sounds"){
                  this.sounds[res.resid]=res.instance;
                }
                if(res.kind=="music"){
                  this.music[res.resid]=res.instance;
                }
                this.resources.splice(i,1);
              }
            }
            this.ready=this.resources.length==0;
          }
        }
        return[ResourceLoader,SoundEffect,SoundEffectBuilder,SpriteSheet,SpriteSheetBuilder,
                  SpriteTile];
      })();
    const[Animation,CameraBase,CharacterComponent,Entity,EntityComponentSystem,Physics2d]=(
          function(){
        class Physics2d{
          constructor(target){
            this.target=target;
            this.xspeed=0;
            this.yspeed=0;
            this.ximpulse=0;
            this.yimpulse=0;
            this.group=[];
            this.map_width=640;
            this.map_height=320;
            this.xcollide=false;
            this.ycollide=false;
            this.collide=false;
            this.collisions=new Set();
          }
          collidePoint(x,y){
            for(let i=0;i<this.group.length;i++)
            {
              if((!!this.group[i].solid)&&this.group[i].rect.collidePoint(x,y)){
                return this.group[i];
              }
            }
            return null;
          }
          impulse(dx,dy){
            this.ximpulse=dx;
            this.yimpulse=dy;
          }
          update(dt){
            this.xcollide=false;
            this.ycollide=false;
            this.collide=false;
            this.collisions=new Set();
            let rect,solid;
            let dx,dy;
            if(this.ximpulse!=0||this.yimpulse!=0){
              dx=dt*this.ximpulse;
              dy=dt*this.yimpulse;
              this.ximpulse*=.95;
              this.yimpulse*=.95;
              if(Math.abs(this.ximpulse)<30){
                this.ximpulse=0;
              }
              if(Math.abs(this.yimpulse)<30){
                this.yimpulse=0;
              }
            }else{
              dx=dt*this.xspeed;
              dy=dt*this.yspeed;
            }
            rect=new Rect(this.target.rect.x+dx,this.target.rect.y,this.target.rect.w,
                          this.target.rect.h);
            solid=false;
            for(let i=0;i<this.group.length;i++)
            {
              if((!!this.group[i].solid)&&rect.collideRect(this.group[i].rect)){
                this.collisions.add(this.group[i]);
                solid=true;
                break;
              }
            }
            if(!solid){
              this.target.rect=rect;
            }else{
              this.xcollide=true;
            }
            rect=new Rect(this.target.rect.x,this.target.rect.y+dy,this.target.rect.w,
                          this.target.rect.h);
            solid=false;
            for(let i=0;i<this.group.length;i++)
            {
              if((!!this.group[i].solid)&&rect.collideRect(this.group[i].rect)){
                this.collisions.add(this.group[i]);
                solid=true;
                break;
              }
            }
            if(!solid){
              this.target.rect=rect;
            }else{
              this.ycollide=true;
            }
            this.collide=this.xcollide||this.ycollide;
          }
        }
        class Animation{
          constructor(target){
            this.target=target;
            this.next_id=0;
            this.animations={};
            this.animation=null;
            this.timer=0;
            this.frame_index=0;
            this.aid=-1;
            this.paused=0;
            this.effect=null;
          }
          register(sheet,tids,frame_duration,params){
            let aid=this.next_id;
            let obj={sheet,tids,frame_duration,xoffset:params.xoffset??0,yoffset:params.yoffset??0,
                          loop:params.loop??true,onend:params.onend??null};
            this.animations[aid]=obj;
            this.next_id+=1;
            return aid;
          }
          setAnimationById(aid){
            if(aid!=this.aid){
              this.timer=0;
              this.frame_index=0;
              this.animation=this.animations[aid];
              this.aid=aid;
            }
            this.paused=0;
          }
          pause(){
            this.paused=1;
            this.frame_index=0;
          }
          update(dt){
            if(this.animation&&this.paused===0){
              this.timer+=dt;
              if(this.timer>this.animation.frame_duration){
                this.timer-=this.animation.frame_duration;
                this.frame_index+=1;
                if(this.frame_index>=this.animation.tids.length){
                  ((this.animation.onend)||(()=>null))();
                  if(this.animation.loop){
                    this.frame_index=0;
                  }else{
                    this.paused=1;
                  }
                }
              }
            }
          }
          paint(ctx){
            if(this.animation){
              let tid=this.animation.tids[this.frame_index];
              let x=this.target.rect.x+this.animation.xoffset;
              let y=this.target.rect.y+this.animation.yoffset;
              ctx.save();
              ((this.effect)||(()=>null))(ctx);
              this.animation.sheet.drawTile(ctx,tid,x,y);
              ctx.restore();
            }
          }
        }
        class CharacterComponent{
          constructor(target){
            this.target=target;
            this.alive=true;
            this.health=3;
            this.hurt_timer=0;
            this.hurt_period=.5;
            this.hurt_cooldown=0;
          }
          update(dt){
            if(this.hurt_timer>0){
              this.hurt_timer-=dt;
              if(this.hurt_timer<0&&this.health<=0){
                this.alive=false;
              }
            }
            if(this.hurt_cooldown>0){
              this.hurt_cooldown-=dt;
            }
          }
          hit(power,direction){
            if(this.hurt_cooldown>0||this.health<=0){
              return;
            }
            this.hurt_cooldown=this.hurt_period+.25;
            this.hurt_timer=this.hurt_period;
            this.health-=power;
            if(direction>0){
              let vector=Direction.vector(direction);
              this.target.physics.impulse(vector.x*100,vector.y*100);
            }
            this.target.animation.effect=(ctx)=>{
              if(this.hurt_timer<=0){
                this.target.animation.effect=null;
              }
              let x;
              x=(this.hurt_timer>this.hurt_period/2)?this.hurt_period-this.hurt_timer:this.hurt_timer;
              
              x=Math.floor(100+200*x);
              ctx.filter=`brightness(${x}%) hue-rotate(-90deg)`;
            };
            if(this.health<=0&&!!this.target.sound_death){
              this.target.sound_death.play();
            }else{
              this.target.sound_hit.play();
            }
          }
        }
        class Entity{
          constructor(){
            this.entid=-1;
            this.active=true;
            this.solid=true;
            this.visible=true;
            this.layer=0;
            this.rect=new Rect(0,0,0,0);
            this.physics=new Physics2d(this);
            this.animation=new Animation(this);
          }
          update(dt){
            this.physics.update(dt);
            this.animation.update(dt);
          }
          paint(ctx){
            this.animation.paint(ctx);
          }
        }
        class CameraBase{
          constructor(){
            this.dirty=true;
          }
          resize(){

          }
          update(dt){

          }
          activeRegion(){
            return new Rect(0,0,0,0);
          }
        }
        class EntityComponentSystem{
          constructor(camera){
            this.next_entid=1;
            this.camera=camera;
            this.entities=[];
            this.active=[];
            this.cache={};
          }
          update(dt){
            this.cache.visible=undefined;
            this.cache.solid=undefined;
            if(this.camera.dirty){
              this.active=[];
              let region=this.camera.activeRegion();
              for(let i=0;i<this.entities.length;i++)
              {
                let ent=this.entities[i];
                ent.active=region.collideRect(ent.rect);
                if(ent.active){
                  this.active.push(ent);
                }
              }
              this.camera.dirty=false;
            }
          }
          addEntity(ent){
            ent.entid=this.next_entid;
            this.next_entid+=1;
            this.entities.push(ent);
          }
          visible(){
            if(this.cache.visible===undefined){
              this.cache.visible=[];
              for(let i=0;i<this.cache.active;i++)
              {
                if(this.cache.active[i].visible){
                  this.cache.visible.push(this.cache.active[i]);
                }
              }
            }
            return this.cache.visible;
          }
          solid(){
            if(this.cache.solid===undefined){
              this.cache.solid=[];
              for(let i=0;i<this.cache.active;i++)
              {
                if(this.cache.active[i].solid){
                  this.cache.solid.push(this.cache.active[i]);
                }
              }
            }
            return this.cache.solid;
          }
        }
        return[Animation,CameraBase,CharacterComponent,Entity,EntityComponentSystem,
                  Physics2d];
      })();
    const[KeyboardInput,TouchInput]=(function(){
        const Keys={LEFT:37,UP:38,RIGHT:39,DOWN:40,SPACE:32,SHIFT:16,CTRL:17,ALT:18};
        
        class KeyboardInput{
          constructor(target){
            this.target=target;
            this.keysDown=[];
            this.buttons=[Keys.CTRL,Keys.SPACE];
          }
          handlePress(kc){
            if(kc>=37&&kc<=40){
              if(!this.keysDown.includes(kc)){
                this.keysDown.push(kc);
              }
              let v=this.getDirectionVector(this.keysDown);
              this.target.setInputDirection(0,v);
            }else{
              let match=0;
              for(let i=0;i<this.buttons.length;i++)
              {
                if(this.buttons[i]==kc){
                  this.target.handleButtonPress(i);
                  match=1;
                }
              }
              if(match===0){
                console.log(`unexpected keycode ${event.keyCode}`);
              }
            }
          }
          handleRelease(kc){
            if(kc>=37&&kc<=40){
              let index=this.keysDown.indexOf(kc);
              if(index!==-1){
                this.keysDown.splice(index,1);
              }
              let v=this.getDirectionVector(this.keysDown);
              this.target.setInputDirection(0,v);
            }else{
              let match=0;
              for(let i=0;i<this.buttons.length;i++)
              {
                if(this.buttons[i]==kc){
                  this.target.handleButtonRelease(i);
                  match=1;
                }
              }
              if(match===0){
                console.log(`unexpected keycode ${event.keyCode}`);
              }
            }
          }
          getDirectionVector(keysDown){
            let x=0;
            let y=0;
            for(let i=0;i<keysDown.length;i++)
            {
              const kc=keysDown[i];
              if(x==0&&kc==Keys.LEFT){
                x=-1;
              }
              if(x==0&&kc==Keys.RIGHT){
                x=1;
              }
              if(y==0&&kc==Keys.UP){
                y=-1;
              }
              if(y==0&&kc==Keys.DOWN){
                y=1;
              }
            }
            return{x,y};
          }
        }
        class TouchInput{
          constructor(target){
            this.target=target;
            this.touches=[];
            this.touch_move=null;
            this.wheels=[];
            this.buttons=[];
            this.button_icons=[];
            this.resize();
          }
          handleMove(whlid,tx,ty){
            if(this.target===null){
              return;
            }
            const cx=this.wheels[whlid].cx;
            const cy=this.wheels[whlid].cy;
            let dx=tx-cx;
            let dy=ty-cy;
            let d=Math.sqrt(dx*dx+dy*dy);
            let cv={x:dx/d,y:dy/d};
            this.wheels[whlid].vector=cv;
            this.target.setInputDirection(whlid,cv);
          }
          handleMoveCancel(whlid){
            if(this.target===null){
              return;
            }
            let cv={x:0,y:0};
            this.wheels[whlid].vector=cv;
            this.target.setInputDirection(whlid,cv);
          }
          handleButtonPress(btnid){
            if(this.target===null){
              return;
            }
            this.target.handleButtonPress(btnid);
          }
          handleButtonRelease(btnid){
            if(this.target===null){
              return;
            }
            this.target.handleButtonRelease(btnid);
          }
          handleTouches(touches){
            if(touches.length){
              this.touches=[...touches];
            }
            for(let j=0;j<this.buttons.length;j++)
            {
              let btn=this.buttons[j];
              let pressed=0;
              for(let i=touches.length-1;i>=0;i--)
              {
                let touch=touches[i];
                const dx=btn.cx-touch.x;
                const dy=btn.cy-touch.y;
                if((dx*dx+dy*dy)<btn.radius*btn.radius){
                  pressed=1;
                  touches.splice(i,1);
                }
              }
              if(pressed&&!btn.pressed){
                btn.pressed=1;
                this.handleButtonPress(j);
              }else if(!pressed&&btn.pressed){
                btn.pressed=0;
                this.handleButtonRelease(j);
              }
            }
            let wheel_events={};
            let touch_move=null;
            for(let j=0;j<this.wheels.length;j++)
            {
              let wheel=this.wheels[j];
              let touched=false;
              for(let i=touches.length-1;i>=0;i--)
              {
                let touch=touches[i];
                const dx=wheel.cx-touch.x;
                const dy=wheel.cy-touch.y;
                const dr=wheel.radius*2;
                if((dx*dx+dy*dy)<dr*dr){
                  touched=true;
                  this.handleMove(j,touch.x,touch.y);
                  touches.splice(i,1);
                  break;
                }
              }
              if(!touched){
                this.handleMoveCancel(j);
              }
            }
          }
          resize(){
            let radius=(gEngine.view.height*.2);
            this.wheels=[{cx:radius,cy:gEngine.view.height-radius,radius:radius,vector:{
                                  x:0,y:0}}];
            radius=32;
            this.buttons=[{cx:gEngine.view.width-radius,cy:gEngine.view.height-3*radius,
                              radius:radius,pressed:0},{cx:gEngine.view.width-3*radius,cy:gEngine.view.height-radius,
                              radius:radius,pressed:0}];
          }
          paint(ctx){
            ctx.lineWidth=2;
            ctx.strokeStyle='red';
            for(let w=0;w<this.wheels.length;w++)
            {
              let whl=this.wheels[w];
              const e2=Math.floor(whl.radius);
              const e3=Math.floor(whl.radius*.7071);
              const cx=Math.floor(whl.cx);
              const cy=Math.floor(whl.cy);
              const cr=Math.floor(whl.radius);
              const dw=16;
              const dr=48;
              ctx.strokeStyle='#00000055';
              ctx.fillStyle='#888888aa';
              ctx.beginPath();
              ctx.roundRect(cx-dr,cy-dw,dr*2,2*dw,8);
              ctx.roundRect(cx-dw,cy-dr,dw*2,2*dr,8);
              ctx.fill();
              ctx.save();
              ctx.beginPath();
              let region=new Path2D();
              region.rect(cx-dr-2,cy-dw-2,dr*2+3,2*dw+3);
              region.rect(cx-dw-2,cy-dr-2,dw*2+3,2*dr+3);
              ctx.clip(region,"evenodd");
              ctx.beginPath();
              ctx.roundRect(cx-dr,cy-dw,dr*2,2*dw,8);
              ctx.roundRect(cx-dw,cy-dr,dw*2,2*dr,8);
              ctx.stroke();
              ctx.restore();
              ctx.strokeStyle='#00000055';
              ctx.fillStyle=(whl.vector.x<-.5)?'#FF770055':'#00000055';
              ctx.beginPath();
              ctx.arc(cx-dr+16,cy,8,0,2*Math.PI);
              ctx.fill();
              ctx.fillStyle=(whl.vector.x>.5)?'#FF770055':'#00000055';
              ctx.beginPath();
              ctx.arc(cx+dr-16,cy,8,0,2*Math.PI);
              ctx.fill();
              ctx.fillStyle=(whl.vector.y<-.5)?'#FF770055':'#00000055';
              ctx.beginPath();
              ctx.arc(cx,cy-dr+16,8,0,2*Math.PI);
              ctx.fill();
              ctx.fillStyle=(whl.vector.y>.5)?'#FF770055':'#00000055';
              ctx.beginPath();
              ctx.arc(cx,cy+dr-16,8,0,2*Math.PI);
              ctx.fill();
            }
            for(let i=0;i<this.buttons.length;i++)
            {
              const dw=16;
              let btn=this.buttons[i];
              ctx.strokeStyle='#00000055';
              ctx.fillStyle='#888888aa';
              ctx.beginPath();
              ctx.arc(btn.cx,btn.cy,btn.radius*.8,0,2*Math.PI);
              ctx.fill();
              ctx.beginPath();
              ctx.arc(btn.cx,btn.cy,btn.radius*.8,0,2*Math.PI);
              ctx.stroke();
              ctx.save();
              ctx.globalAlpha=.5;
              if(this.button_icons[i]){
                this.button_icons[i].sheet.drawTileScaled(ctx,this.button_icons[i].tid,
                                  btn.cx-16,btn.cy-16,32,32);
              }
              ctx.restore();
            }
            this.touches.forEach(t=>{
                ctx.fillStyle='#888888aa';
                ctx.beginPath();
                ctx.arc(t.x,t.y,5,0,2*Math.PI);
                ctx.fill();
              });
          }
        }
        return[KeyboardInput,TouchInput];
      })();
    const[CanvasEngine,GameScene]=(function(){
        class GameScene{
          pause(paused){

          }
          update(dt){

          }
          paint(ctx){

          }
          resize(){

          }
          handleTouches(touches){

          }
          handleKeyPress(keyCode){

          }
          handleKeyRelease(keyCode){

          }
        }
        const style={"canvas":'dcs-3c12219a-0'};
        class CanvasEngine extends DomElement {
          constructor(width,height,settings=null){
            super("canvas",{"width":width,"height":height,className:style.canvas});
            
            this.scene=null;
            this.ctx=null;
            this.lastTime=null;
            this.settings=settings??{};
            this.settings.portrait=this.settings.portrait??1;
            this.delta_accum=0;
            this.onReady=null;
            this.view={x:0,y:0,width:640,height:320,rotate:0,scale:1,availWidth:0,
                          availHeight:0};
            this.touch_event=null;
            this.paused=false;
          }
          elementMounted(){
            this.ctx=this.getDomNode().getContext("2d");
            console.log(`2d context created}`);
            this.handleResize(this.props.width,this.props.height);
            if(this.onReady){
              this.onReady();
            }
            window.requestAnimationFrame(this.render.bind(this));
          }
          _getMouseTouches(event){
            event.preventDefault();
            const rect=this.getDomNode().getBoundingClientRect();
            const x=(event.clientX-rect.left)/this.view.scale-this.view.x;
            const y=(event.clientY-rect.top)/this.view.scale-this.view.y;
            return[{x,y}];
          }
          onMouseDown(event){
            if(event.buttons&1){
              const touches=this._getMouseTouches(event);
              if(!this.paused){
                this.scene.handleTouches(touches);
              }
            }
          }
          onMouseMove(event){
            if(event.buttons&1){
              const touches=this._getMouseTouches(event);
              if(!this.paused){
                this.scene.handleTouches(touches);
              }
            }
          }
          onMouseUp(event){
            if(!this.paused){
              this.scene.handleTouches([]);
            }
          }
          _getTouches(event){
            event.preventDefault();
            const rect=this.getDomNode().getBoundingClientRect();
            return Array.from(event.targetTouches).map(touch=>{
                if(this.view.rotate){
                  return{"x":(touch.clientY-rect.top-this.view.x),"y":this.view.height-(
                                          touch.clientX-rect.left-this.view.y)};
                }else{
                  return{"x":(touch.clientX-rect.left-this.view.x),"y":(touch.clientY-rect.top-this.view.y)};
                  
                }
              });
          }
          onTouchStart(event){
            const touches=this._getTouches(event);
            console.log("start",touches.length,[...touches]);
            if(!this.paused){
              this.scene.handleTouches(touches);
            }
          }
          onTouchMove(event){
            const touches=this._getTouches(event);
            console.log("move",touches.length,[...touches]);
            if(!this.paused){
              this.scene.handleTouches(touches);
            }
          }
          onTouchEnd(event){
            const touches=this._getTouches(event);
            console.log("end",touches.length,[...touches]);
            if(!this.paused){
              this.scene.handleTouches(touches);
            }
          }
          handleResize(width,height){
            this.view.x=32;
            this.view.y=8;
            if(daedalus.platform.isMobile){
              this.view.width=Math.floor((height-32)/32)*32;
              this.view.height=Math.floor((width)/32)*32;
            }else{
              this.view.width=Math.floor(640.0);
              this.view.height=Math.floor(360.0);
            }
            if(!!this.settings.portrait){
              let t=this.view.width;
              this.view.width=this.view.height;
              this.view.height=t;
            }
            this.view.availWidth=width;
            this.view.availHeight=height;
            if(width/height<0.75&&!this.settings.portrait){
              this.view.rotate=1;
            }else{
              this.view.rotate=0;
            }
            this.view.scale=1;
            if(this.view.rotate){
              if(height>2*this.view.width&&width>2*this.view.height){
                this.view.scale=2;
              }
            }else{
              if(width>2*this.view.width&&height>2*this.view.height){
                this.view.scale=2;
              }
            }
            if(!daedalus.platform.isMobile&&!this.view.rotate){
              this.view.x=Math.floor((width-(this.view.width*this.view.scale))/(2*this.view.scale));
              
              this.view.y=Math.min(32,Math.floor((height-(this.view.height*this.view.scale))/(
                                      2*this.view.scale)));
            }else if(daedalus.platform.isMobile){
              if(this.view.rotate){
                this.view.x=Math.floor((height-(this.view.width*this.view.scale))/(
                                      2*this.view.scale));
                this.view.y=Math.floor((width-(this.view.height*this.view.scale))/(
                                      2*this.view.scale));
              }else{
                this.view.x=Math.floor((width-(this.view.width*this.view.scale))/(
                                      2*this.view.scale));
                this.view.y=Math.floor((height-(this.view.height*this.view.scale))/(
                                      2*this.view.scale));
              }
            }else{
              this.view.x=0;
              this.view.y=0;
            }
            if(this.scene){
              this.scene.resize();
            }
          }
          handleKeyPress(event){
            const kc=event.keyCode;
            if(kc<112){
              if(kc==19){
                this.paused=!this.paused;
                this.scene.pause(this.paused);
              }else if(!this.paused){
                this.scene.handleKeyPress(kc);
                event.preventDefault();
              }
            }
          }
          handleKeyRelease(event){
            const kc=event.keyCode;
            if(kc<112&&kc!=19){
              if(!this.paused){
                this.scene.handleKeyRelease(kc);
                event.preventDefault();
              }
            }
          }
          renderFrame(){
            const ctx=this.ctx;
            if(ctx===null){
              console.log(ctx);
              return;
            }
            ctx.resetTransform();
            ctx.clearRect(0,0,this.props.width,this.props.height);
            ctx.scale(this.view.scale,this.view.scale);
            if(this.view.rotate){
              ctx.rotate((90*Math.PI)/180);
              ctx.translate(0,-this.props.width/this.view.scale);
            }
            ctx.translate(this.view.x,this.view.y);
            ctx.webkitImageSmoothingEnabled=false;
            ctx.mozImageSmoothingEnabled=false;
            ctx.imageSmoothingEnabled=false;
            this.scene.paint(ctx);
          }
          render(){
            let now=performance.now();
            let dt=0.016666666666666666;
            if(this.lastTime!=null){
              if(!this.paused){
                this.delta_accum+=(now-this.lastTime)/1000.0;
                let n=0;
                while(this.delta_accum>dt){
                  this.delta_accum-=dt;
                  this.scene.update(dt);
                  n+=1;
                }
                if(n>0){
                  this.renderFrame();
                }
              }
              this.fps=Math.floor(1.0/dt);
            }
            this.lastTime=now;
            window.requestAnimationFrame(this.render.bind(this));
          }
        }
        return[CanvasEngine,GameScene];
      })();
    const[]=(function(){
        return[];
      })();
    return{Animation,CameraBase,CanvasEngine,CharacterComponent,Direction,Entity,
          EntityComponentSystem,GameScene,KeyboardInput,Physics2d,Rect,ResourceLoader,
          SoundEffect,SoundEffectBuilder,SpriteSheet,SpriteSheetBuilder,SpriteTile,TouchInput,
          randomChoice,randomNumber,randomRange,shuffle};
  })(daedalus);
physics=(function(){
    "use strict";
    function distance(p1,p2){
      const dx=p2.x-p1.x;
      const dy=p2.y-p1.y;
      return Math.sqrt(dx*dx+dy*dy);
    }
    function solve_linear(p1,p2){
      const d=(p2.x-p1.x);
      if(d==0){
        throw`y = ${p1.x}`;
      }
      const m=(p2.y-p1.y)/d;
      const b=p1.y-m*p1.x;
      return[m,b];
    }
    function compute_vector(p1,p2){
      return[(p2.x-p1.x),(p2.y-p1.y)];
    }
    function quadform(a,b,c){
      const discriminant=b*b-4*a*c;
      const denominator=2*a;
      if(a==0){
        return[-c/b];
      }else if(discriminant>0){
        return[(-b+Math.sqrt(discriminant))/denominator,(-b-Math.sqrt(discriminant))/denominator];
        
      }else if(discriminant==0){
        return[-b/denominator];
      }else{
        return[];
      }
    }
    function intercept_line(p1,p2,p3,p4){
      let eq1;
      if(p1.x==p2.x){
        eq1=[p1.x];
      }else{
        eq1=solve_linear(p1,p2);
      }
      let eq2;
      if(p3.x==p4.x){
        eq2=[p3.x];
      }else{
        eq2=solve_linear(p3,p4);
      }
      if(eq1.length==1&&eq2.length==1){
        if(eq1[0]!=eq2[0]){
          return null;
        }
        const[a,b]=[p1.y,p2.y].sort((a,b)=>a-b);
        if((p3.y<a||p3.y>b)&&(p4.y<a||p4.y>b)){
          return null;
        }
        const d1=distance(p1,p3);
        const d2=distance(p1,p4);
        if(d1<d2){
          return{point:p3,tangent:[0,p3.y]};
        }else{
          return{point:p4,tangent:[0,p4.y]};
        }
      }else if(eq1.length==1){
        const[xa,xb]=[p3.x,p4.x].sort((a,b)=>a-b);
        if(p1.x<xa||p1.x>xb){
          return null;
        }
        const y=eq2[0]*p1.x+eq2[1];
        const[ya,yb]=[p1.y,p2.y].sort((a,b)=>a-b);
        if(y<ya||y>yb){
          return null;
        }
        return{point:{x:p1.x,y},tangent:eq2};
      }else if(eq2.length==1){
        const[xa,xb]=[p1.x,p2.x].sort((a,b)=>a-b);
        if(p3.x<xa||p3.x>xb){
          return null;
        }
        const y=eq1[0]*p3.x+eq1[1];
        const[ya,yb]=[p3.y,p4.y].sort((a,b)=>a-b);
        if(y<ya||y>yb){
          return null;
        }
        return{point:{x:p3.x,y},tangent:eq2};
      }else{
        const denominator=(eq1[0]-eq2[0]);
        const numerator=(eq2[1]-eq1[1]);
        if(denominator==0){
          return null;
        }
        const x=numerator/denominator;
        const y=eq1[0]*x+eq1[1];
        const[a,b]=[p1.x,p2.x].sort((a,b)=>a-b);
        if(x<a||x>b){
          return null;
        }
        return{point:{x,y},tangent:eq2};
      }
    }
    function intercept_curve(p1,p2,curve_eq,interval){
      let collision_points=[];
      let x1,y1;
      if(p1.x===p2.x){
        if(p1.x<interval[0]||p1.x>interval[1]){
          return null;
        }
        x1=p1.x;
        y1=curve_eq[0]*x1*x1+curve_eq[1]*x1+curve_eq[2];
        const[a,b]=[p1.y,p2.y].sort((a,b)=>a-b);
        if(y1<a||y1>b){
          return null;
        }
      }else{
        const line_eq=solve_linear(p1,p2);
        const ap=curve_eq[0],bp=curve_eq[1]-line_eq[0],cp=curve_eq[2]-line_eq[1];
        
        const intercept_roots=quadform(ap,bp,cp).filter((x)=>{
            return x>=interval[0]&&x<=interval[1];
          });
        if(intercept_roots.length==0){
          return null;
        }
        const cmp=(a,b)=>distance(p1,a.point)-distance(p1,b.point);
        root=intercept_roots.sort(cmp)[0];
        x1=root;
        y1=line_eq[0]*x1+line_eq[1];
      }
      const mt=2*curve_eq[0]*x1+curve_eq[1];
      const bt=-mt*x1+y1;
      return{point:{x:x1,y:y1},tangent:[mt,bt]};
    }
    function intercept_circle(p1,p2,center,radius){
      let intercept_points=[];
      p1={x:p1.x-center.x,y:p1.y-center.y};
      p2={x:p2.x-center.x,y:p2.y-center.y};
      if(p1.x==p2.x){
        const delta=radius*radius-p1.x*p1.x;
        if(delta>=0){
          const ya=+Math.sqrt(radius*radius-p1.x*p1.x);
          const yb=-Math.sqrt(radius*radius-p1.x*p1.x);
          intercept_points=[{x:p1.x,y:ya},{x:p1.x,y:yb}];
        }
      }else{
        const line_eq=solve_linear(p1,p2);
        const ap=line_eq[0]*line_eq[0]+1;
        const bp=2*line_eq[1]*line_eq[0];
        const cp=line_eq[1]*line_eq[1]-radius*radius;
        const intercept_roots=quadform(ap,bp,cp);
        if(intercept_roots.length==0){
          return null;
        }
        intercept_roots[0];
        intercept_points=intercept_roots.map(r=>({x:r,y:line_eq[0]*r+line_eq[1]}));
        
      }
      if(intercept_points.length==0){
        return null;
      }
      let point;
      if(intercept_points.length==2){
        const d1=distance(p1,intercept_points[0]);
        const d2=distance(p1,intercept_points[1]);
        point=(d1<d2)?intercept_points[0]:intercept_points[1];
      }else{
        point=intercept_points[0];
      }
      point={x:point.x+center.x,y:point.y+center.y};
      let tangent;
      if(center.y==point.y){
        tangent=[point.x];
      }else if(center.x==point.x){
        tangent=[0,point.y+center.y];
      }else{
        const perp_eq=solve_linear(center,point);
        const mt=-1/perp_eq[0];
        const bt=point.y-mt*point.x;
        tangent=[mt,bt];
      }
      return{point,tangent};
    }
    function intercept_shape(p1,p2,shape){
      const collisions=shape.map((segment,index)=>{
          let x=null;
          switch(segment.type){
            case "line":x=intercept_line(p1,p2,segment.p1,segment.p2);break;case "curve":x=intercept_curve(
                          p1,p2,segment.curve,segment.interval);break;case "circle":x=intercept_circle(
                          p1,p2,segment.center,segment.radius);break;default:break;;
          }
          if(x!=null){
            x.type=segment.type;
          }
          return x;
        }).filter(x=>x!==null);
      if(collisions.length===0){
        return null;
      }
      const cmp=(a,b)=>distance(p1,a.point)-distance(p1,b.point);
      const result=collisions.sort(cmp)[0];
      return result;
    }
    function dot2(v1,v2){
      return v1[0]*v2[0]+v1[1]*v2[1];
    }
    function reflect(v,n){
      const scale=2*dot2(v,n);
      return[v[0]-scale*n[0],v[1]-scale*n[1]];
    }
    function compute_normal(p,x1,y1,tanget_eq){
      const mt=tanget_eq[0];
      const bt=tanget_eq[1];
      if(tanget_eq.length==1){
        const hdir=compute_vector(p,{x:x1,y:y1});
        return(hdir[0]>=0)?[-1,0]:[1,0];
      }else if(tanget_eq[0]==0){
        const vdir=compute_vector(p,{x:x1,y:y1});
        return(vdir[1]>=0)?[0,-1]:[0,1];
      }
      const mp=-1/tanget_eq[0];
      const bp=y1-mp*x1;
      const xa=(x1-1);
      const xb=(x1+1);
      const ya=mp*xa+bp;
      const yb=mp*xb+bp;
      const dx=2;
      const dy=yb-ya;
      const d1=distance(p,{x:x1+dx,y:y1+dy});
      const d2=distance(p,{x:x1-dx,y:y1-dy});
      let n;
      if(d1<d2){
        n=[dx,dy];
      }else{
        n=[-dx,-dy];
      }
      const nm=Math.sqrt(n[0]*n[0]+n[1]*n[1]);
      n=[n[0]/nm,n[1]/nm];
      return n;
    }
    return{compute_normal,compute_vector,distance,intercept_circle,intercept_curve,
          intercept_line,intercept_shape,quadform,reflect};
  })();
breakout2=(function(daedalus,engine,physics){
    "use strict";
    const StyleSheet=daedalus.StyleSheet;
    const DomElement=daedalus.DomElement;
    const TextElement=daedalus.TextElement;
    const ListItemElement=daedalus.ListItemElement;
    const ListElement=daedalus.ListElement;
    const HeaderElement=daedalus.HeaderElement;
    const ButtonElement=daedalus.ButtonElement;
    const LinkElement=daedalus.LinkElement;
    const CanvasEngine=engine.CanvasEngine;
    const randomRange=engine.randomRange;
    const randomNumber=engine.randomNumber;
    const randomChoice=engine.randomChoice;
    const shuffle=engine.shuffle;
    const SoundEffect=engine.SoundEffect;
    const SpriteSheetBuilder=engine.SpriteSheetBuilder;
    const SpriteSheet=engine.SpriteSheet;
    const ResourceLoader=engine.ResourceLoader;
    const CameraBase=engine.CameraBase;
    const Direction=engine.Direction;
    const TouchInput=engine.TouchInput;
    const KeyboardInput=engine.KeyboardInput;
    const Rect=engine.Rect;
    const Entity=engine.Entity;
    const CharacterComponent=engine.CharacterComponent;
    const GameScene=engine.GameScene;
    const style={"body":'dcs-702cb152-0',"bodyRotate":'dcs-702cb152-1',"main":'dcs-702cb152-2',
          "item_hover":'dcs-702cb152-3',"item":'dcs-702cb152-4',"item_file":'dcs-702cb152-5'};
    
    class Agent{
      constructor(){
        this.x=0;
        this.y=0;
        this.width=0;
        this.height=0;
        this.visible=true;
        this.destroy=false;
        this.solid=false;
        this.layer=0;
      }
      update(dt){

      }
      paint(ctx){

      }
      collisionRect(){
        return{x:this.x,y:this.y,width:this.width,height:this.height};
      }
      collisionShape(){
        const rect=this.collisionRect();
        const tl={x:rect.x,y:rect.y},tr={x:rect.x+rect.width,y:rect.y},bl={x:rect.x,
                  y:rect.y+rect.height},br={x:rect.x+rect.width,y:rect.y+rect.height};
        const shape=[{type:"line",p1:tl,p2:bl},{type:"line",p1:tl,p2:tr},{type:"line",
                      p1:tr,p2:br},{type:"line",p1:bl,p2:br}];
        return shape;
      }
    }
    const collision={point2rect:function(px,py,tx,ty,tw,th){
        return px<tx+tw&&px>tx&&py<ty+th&&py>ty;
      },point2rectTB:function(px,py,tx,ty,tw,th){
        return py<ty+th&&py>ty;
      },point2rectLR:function(px,py,tx,ty,tw,th){
        return px<tx+tw&&px>tx;
      },rect2rect:function(px,py,pw,ph,tx,ty,tw,th){
        return px<tx+tw&&px+pw>tx&&py<ty+th&&py+ph>ty;
      }};
    class Ball extends Agent {
      constructor(){
        super();
        this.basespeed=80;
        this.dx=this.basespeed*.7071;
        this.dy=-this.basespeed*.7071;
        this.radius=5;
        this.color='blue';
        this.layer=10;
        this.x=100;
        this.y=400;
        this.trail=[];
        this.particles=[];
        this.hit=null;
      }
      doCollide(rect){
        if(this.y<rect.y||this.y>rect.y+rect.height){
          this.dy=-this.dy;
        }else if(this.x>rect.x&&this.x<rect.x+rect.width){
          if(this.y<rect.y+rect.height/2){
            this.y=rect.y-this.radius;
            this.dy=-Math.abs(this.dy);
          }else if(this.y>rect.y+rect.height/2){
            this.y=rect.y+rect.height+this.radius;
            this.dy=Math.abs(this.dy);
          }
        }
        if(this.x<rect.x||this.x>rect.x+rect.width){
          this.dx=-this.dx;
        }else if(this.y>rect.y&&this.y<rect.y+rect.height){
          if(this.x<rect.x+rect.width/2){
            this.x=rect.x-this.radius;
            this.dx=-Math.abs(this.dx);
          }else if(this.x>rect.x+rect.width/2){
            this.x=rect.x+rect.width+this.radius;
            this.dx=Math.abs(this.dx);
          }
        }
        this.collide=true;
      }
      update(dt){
        this.move_x(dt);
        this.move_y(dt);
        this.trail.push({x:this.x,y:this.y});
        if(this.trail.length>5){
          this.trail.shift();
        }
      }
      move_x(dt){
        let x=this.x;
        let dx=this.dx*dt;
        const agents=gEngine.scene.agents;
        const view=gEngine.view;
        for(let agent of agents){
          if(agent.solid){
            const rect=agent.collisionRect();
            if(collision.point2rect(x+dx,this.y,rect.x,rect.y,rect.width,rect.height)){
            
              const p1={x:x,y:this.y};
              const p2={x:x+dx,y:this.y};
              const ps={x:x-dx,y:this.y};
              const shape=agent.collisionShape();
              const result=physics.intercept_shape(p1,p2,shape);
              if(result!==null){
                if(agent instanceof Brick){
                  agent.decrementHealth();
                }
                const n=physics.compute_normal(ps,result.point.x,result.point.y,result.tangent);
                
                this.hit={normal:n,tangent:result.tangent,point:result.point};
              }
              if(agent instanceof Paddle){
                let pr=(agent.x-this.x)/agent.width;
                console.log("x hit paddle",pr);
              }
              dx=-dx;
              break;
            }
          }
        }
        if(x+dx>view.width){
          this.x=view.width;
          this.dx=-Math.abs(dx/dt);
        }else if(x+dx<0){
          this.x=0;
          this.dx=Math.abs(dx/dt);
        }else{
          this.x=x+dx;
          this.dx=dx/dt;
        }
      }
      move_y(dt){
        let y=this.y;
        let dy=this.dy*dt;
        const agents=gEngine.scene.agents;
        const view=gEngine.view;
        for(let agent of agents){
          if(agent.solid){
            const rect=agent.collisionRect();
            if(collision.point2rect(this.x,y+dy,rect.x,rect.y,rect.width,rect.height)){
            
              const p1={x:this.x,y:y};
              const p2={x:this.x,y:y+dy};
              const ps={x:this.x,y:y-dy};
              const shape=agent.collisionShape();
              const result=physics.intercept_shape(p1,p2,shape);
              if(result!==null){
                if(agent instanceof Brick){
                  agent.decrementHealth();
                }
                const n=physics.compute_normal(ps,result.point.x,result.point.y,result.tangent);
                
                this.hit={normal:n,tangent:result.tangent,point:result.point};
              }
              if(agent instanceof Paddle){
                if(agent.y>this.y){
                  let pr=(this.x-agent.x)/agent.width;
                  pr+=0.5;
                  pr=Math.max(0.0,Math.min(1.0,pr));
                  let v1,v2,dx3,dy3;
                  v1={x:this.dx,y:this.dy};
                  if(pr<0.3){
                    pr=1.0-(pr/0.3);
                    v2={x:-this.basespeed,y:this.basespeed};
                    console.log("y hit paddle <",pr);
                    dx3=pr*v2.x+(1-pr)*v1.x;
                    dy3=pr*v2.y+(1-pr)*v1.y;
                    dy=dy3*dt;
                    this.dx=dx3;
                  }else if(pr>0.7){
                    pr=(pr-0.7)/0.3;
                    v2={x:this.basespeed,y:this.basespeed};
                    console.log("y hit paddle >",pr);
                    dx3=pr*v2.x+(1-pr)*v1.x;
                    dy3=pr*v2.y+(1-pr)*v1.y;
                    dy=dy3*dt;
                    this.dx=dx3;
                  }
                }
              }
              dy=-dy;
              break;
            }
          }
        }
        if(y+dy>view.height){
          this.y=view.height;
          this.dy=-Math.abs(dy/dt);
        }else if(y+dy<0){
          this.y=0;
          this.dy=Math.abs(dy/dt);
        }else{
          this.y=y+dy;
          this.dy=dy/dt;
        }
      }
      paint(ctx){
        for(let i=this.trail.length-1;i>=0;i--)
        {
          ctx.beginPath();
          ctx.arc(this.trail[i].x,this.trail[i].y,this.radius-(this.trail.length-i)/4,
                      0,Math.PI*2);
          ctx.closePath();
          ctx.fillStyle=`rgba(0,0,255, ${(1+i)/this.trail.length/4})`;
          ctx.fill();
        }
        ctx.beginPath();
        ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
        ctx.closePath();
        ctx.fillStyle=this.color;
        ctx.fill();
        if(this.hit!==null){
          const p=this.hit.point;
          const tangent=this.hit.tangent;
          const normal=this.hit.normal;
          if(tangent.length==2){
            const len=100;
            const w=Math.sqrt((len*len)/(4+4*tangent[0]*tangent[0]));
            const xt1=p.x-w;
            const xt2=p.x+w;
            const yt1=tangent[0]*xt1+tangent[1];
            const yt2=tangent[0]*xt2+tangent[1];
            ctx.beginPath();
            ctx.moveTo(xt1,yt1);
            ctx.lineTo(xt2,yt2);
            ctx.closePath();
            ctx.lineWidth=2;
            ctx.strokeStyle='orange';
            ctx.stroke();
          }else{
            const xt1=tangent[0];
            const xt2=tangent[0];
            const yt1=p.y-50;
            const yt2=p.y+50;
            ctx.beginPath();
            ctx.moveTo(xt1,yt1);
            ctx.lineTo(xt2,yt2);
            ctx.closePath();
            ctx.lineWidth=2;
            ctx.strokeStyle='orange';
            ctx.stroke();
          }
          const xn1=p.x;
          const xn2=p.x+50*normal[0];
          const yn1=p.y;
          const yn2=p.y+50*normal[1];
          ctx.beginPath();
          ctx.moveTo(xn1,yn1);
          ctx.lineTo(xn2,yn2);
          ctx.closePath();
          ctx.lineWidth=2;
          ctx.strokeStyle='red';
          ctx.stroke();
        }
      }
    }
    class Paddle extends Agent {
      constructor(){
        super();
        this.solid=true;
        this.radius=5;
        this.color='blue';
        this.x=100;
        this.y=100;
        this.xp=100;
        this.dx=0;
        this.width=100;
        this.height=this.radius*2;
        this.touch=null;
      }
      handleTouches(touches){
        if(touches.length>0){
          this.touch=touches[0];
        }else{
          this.touch=null;
        }
      }
      update(dt){
        const view=gEngine.view;
        const factor=1.5;
        if(this.touch!==null){
          let x=(view.width/2)+factor*(this.touch.x-view.width/2);
          x=Math.min(view.width-this.width/2,x);
          x=Math.max(this.width/2,x);
          this.dx=(x-this.xp)*.75+(this.dx*.25);
          this.xp=this.x;
          this.x=x;
        }
      }
      paint(ctx){
        ctx.beginPath();
        ctx.arc(this.x-this.width/2,this.y,this.radius,0,Math.PI*2,true);
        ctx.arc(this.x+this.width/2,this.y,this.radius,0,Math.PI*2,true);
        ctx.closePath();
        ctx.fillStyle=this.color;
        ctx.fill();
        ctx.fillRect(this.x-this.width/2,this.y-this.radius,this.width,2*this.radius);
        
      }
      collisionRect(){
        return{x:this.x-this.radius-this.width*.5,y:this.y-this.radius,width:this.width+this.radius*2,
                  height:this.radius*2};
      }
    }
    const brick_color=["#EE0000","#FF9500","#EEEE00","#008000","#00BBBB","#0000BB",
          "#800080","#DDDDDD","#C0C0C0","#17202a"];
    class Brick extends Agent {
      constructor(x,y,width,height){
        super();
        this.solid=true;
        this.color=null;
        this.x=x;
        this.y=y;
        this.width=width;
        this.height=height;
        this.health=3;
      }
      update(dt){

      }
      paint(ctx){
        const thickness=2;
        ctx.fillStyle='black';
        ctx.fillRect(this.x-this.width/2,this.y-this.height/2,this.width,this.height);
        
        ctx.fillStyle=this.color??brick_color[this.health-1];
        ctx.fillRect(this.x-this.width/2+thickness,this.y-this.height/2+thickness,
                  this.width-2*thickness,this.height-2*thickness);
      }
      decrementHealth(){
        this.health-=1;
        if(this.health<=0){
          this.destroy=true;
        }
        return this.health;
      }
      collisionRect(){
        return{x:this.x-this.width/2,y:this.y-this.height/2,width:this.width,height:this.height};
        
      }
    }
    class BrickShape extends Agent {
      constructor(x,y,radius){
        super();
        this.solid=true;
        this.x=x;
        this.y=y;
        this.health=99;
        this.layer=99;
        this.shape=[{type:"circle",center:{x:0,y:0},radius:radius}];
        this.rect=this.getCollisionRectTemplate();
        this.width=this.rect.width;
        this.width=this.rect.height;
      }
      draw(view){
        const rect=this.collisionRect();
        view.ctx.fillStyle='red';
        view.ctx.strokeStyle='#000033';
        view.ctx.fillStyle='#0000AA';
        this.shape.forEach(segment=>{
            switch(segment.type){
              case 'line':view.ctx.beginPath();view.ctx.moveTo(this.x+segment.p1.x,
                              this.y+segment.p1.y);view.ctx.lineTo(this.x+segment.p2.x,this.y+segment.p2.y);
                            view.ctx.stroke();break;case 'curve':break;case 'circle':view.ctx.beginPath(
                            );view.ctx.arc(this.x+segment.center.x,this.y+segment.center.y,segment.radius,
                              0,2*Math.PI);view.ctx.stroke();view.ctx.beginPath();view.ctx.arc(
                              this.x+segment.center.x,this.y+segment.center.y,segment.radius,0,
                              2*Math.PI);view.ctx.fill();break;;
            }
          });
      }
      getCollisionRectTemplate(){
        const shape=this.collisionShape();
        let left=Number.MAX_VALUE,right=Number.MIN_VALUE,top=Number.MAX_VALUE,bottom=Number.MIN_VALUE;
        
        this.shape.forEach(segment=>{
            switch(segment.type){
              case 'line':if(segment.p1.x<left){
                left=segment.p1.x;
              };if(segment.p2.x<left){
                left=segment.p2.x;
              };if(segment.p1.x>right){
                right=segment.p1.x;
              };if(segment.p2.x>right){
                right=segment.p2.x;
              };if(segment.p1.y<top){
                top=segment.p1.y;
              };if(segment.p2.y<top){
                top=segment.p2.y;
              };if(segment.p1.y>bottom){
                bottom=segment.p1.y;
              };if(segment.p2.y>bottom){
                bottom=segment.p2.y;
              };break;case 'curve':break;case 'circle':segment.center.x-segment.radius;
                            if(segment.center.x-segment.radius<left){
                left=segment.center.x-segment.radius;
              };if(segment.center.x+segment.radius>right){
                right=segment.center.x+segment.radius;
              };if(segment.center.y-segment.radius<top){
                top=segment.center.y-segment.radius;
              };if(segment.center.y+segment.radius>bottom){
                bottom=segment.center.y+segment.radius;
              };break;;
            }
          });
        return{x:left,y:top,width:right-left,height:bottom-top};
      }
      collisionRect(){
        return{x:this.x+this.rect.x,y:this.y+this.rect.y,width:this.rect.width,height:this.rect.height};
        
      }
      collisionShape(){
        const shape=this.shape.map(segment=>{
            switch(segment.type){
              case 'line':return{type:"line",p1:{x:this.x+segment.p1.x,y:this.y+segment.p1.y},
                              p2:{x:this.x+segment.p2.x,y:this.y+segment.p2.y}};case 'curve':break;
                            case 'circle':return{type:"circle",center:{x:this.x+segment.center.x,
                                  y:this.y+segment.center.y},radius:segment.radius};break;;
            }
          });
        return shape;
      }
    }
    class BreakoutScene extends GameScene {
      constructor(){
        super();
        this.agents=[];
        console.log("init scene");
        this.initGame();
      }
      handleTouches(touches){
        if(!!this.paddle){
          this.paddle.handleTouches(touches);
        }
      }
      resize(){
        console.log("Resize?");
      }
      update(dt){
        for(let i=this.agents.length-1;i>=0;i--)
        {
          const agent=this.agents[i];
          agent.update(dt);
          if(!!agent.destroy){
            this.agents.splice(i,1);
          }
        }
        this.agents.forEach(agent=>{
            agent.update(dt);
          });
      }
      paint(ctx){
        ctx.strokeStyle="#FF0000";
        ctx.beginPath();
        ctx.rect(0,0,gEngine.view.width,gEngine.view.height);
        ctx.stroke();
        const cmp=(a,b)=>(a.layer-b.layer)||(a.y-b.y)||(a.x-b.x);
        this.agents.sort(cmp).forEach(agent=>{
            if(agent.visible){
              agent.paint(ctx);
            }
          });
      }
      initGame(){
        const nbricks=15;
        const width=gEngine.view.width;
        const height=gEngine.view.height;
        let template=["     ###       ###     ","    #...#     #...#    ","   #..#..#ggg#..#..#   ",
                  "  gg#...#ggggg#...#gg  "," gggg###ggggggg###gggg ","ggggggggggggggggggggggg",
                  "ggggggggggggggggggggggg","gggggggg##ggg##gggggggg","gggggggg##ggg##gggggggg",
                  "ggggggggggggggggggggggg","ggg##ggggggggggggg##ggg","ggggg#############ggggg",
                  "  ggggggggggggggggggg  ","  ggggggggggggggggggg  ","     ggggggggggggg     ",
                  "     ggggggggggggg     "];
        let brwidth=Math.floor((width-16)/template[0].length);
        let brheight=brwidth;
        console.log("x",width,template[0].length,brwidth);
        console.log("x",Math.floor((width-template[0].length*brwidth)/2));
        for(let j=0;j<template.length;j++)
        {
          let row=template[j];
          let x1=Math.floor((width-(row.length-1)*brwidth)/2);
          let y1=Math.floor(height/6+j*brheight);
          for(let i=0;i<row.length;i++)
          {
            if(row[i]===" "){
              continue;
            }
            const brick=new Brick(x1+i*brwidth,y1,brwidth,brheight);
            if(row[i]=="#"){
              brick.health=1;
              brick.color='#222222';
            }
            if(row[i]=="."){
              brick.health=1;
              brick.color='#CCCCCC';
            }
            if(row[i]=="g"){
              brick.health=1;
              brick.color='#33AA33';
            }
            this.agents.push(brick);
          }
        }
        this.paddle=new Paddle();
        this.paddle.y=Math.floor(height*4/5);
        this.paddle.x=width/2-this.paddle.width/2;
        this.agents.push(this.paddle);
        this.ball=new Ball();
        this.ball.x=this.paddle.x+this.paddle.width/2;
        this.ball.y=this.paddle.y-32;
        this.agents.push(this.ball);
      }
    }
    class Application extends DomElement {
      constructor(){
        super("div",{className:style.main},[]);
        const body=document.getElementsByTagName("BODY")[0];
        body.className=style.body;
        console.log("build app");
      }
      elementMounted(){
        this.canvas=this.appendChild(new CanvasEngine(window.innerWidth,window.innerHeight,
                      {portrait:1}));
        window.gEngine=this.canvas;
        this.canvas.onReady=()=>{
          this.canvas.scene=new BreakoutScene();
          console.log("scene created");
        };
        window.addEventListener("keydown",this.canvas.handleKeyPress.bind(this.canvas));
        
        window.addEventListener("keyup",this.canvas.handleKeyRelease.bind(this.canvas));
        
        window.addEventListener("resize",this.handleResize.bind(this));
      }
      handleResize(){
        const canvas=this.canvas.getDomNode();
        canvas.width=window.innerWidth;
        canvas.height=window.innerHeight;
        this.canvas.handleResize(window.innerWidth,window.innerHeight);
      }
    }
    return{Application};
  })(daedalus,engine,physics);
</script>
</head>
<body>
<div id="root">Enable Javascript to render site.</div>
</body>
<script type="text/javascript">
const document_root = document.getElementById("root")
while (document_root.hasChildNodes()) {
    document_root.removeChild(document_root.lastChild);
}
daedalus.render(document_root, new breakout2.Application())
</script>
</html>
