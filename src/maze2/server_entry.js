

$import("axertc_server", {ServerLobby, ServerEngine})
$import("axertc_common", {CspMap, ServerCspMap})
$import("maze_common", {MazeMap})


class DemoLobby extends ServerLobby {


    constructor() {
        super();

        this.world_timer = 0;

        this.map = new ServerCspMap(new MazeMap())

        this.enable_ghosts = false

        this.player2entity = {}

        this.ghosts = {}
    }

    join(playerId) {
        this.map.join(playerId);

        this.players[playerId] = true

        const event1 = this.map.map.sendCreateObjectEvent("Player", {x:256, y:256, playerId:playerId})

        this.player2entity[playerId] = event1.entid

        if (this.enable_ghosts) {
            const event2 = this.map.map.sendCreateObjectEvent("Player", {x:256, y:256})
            this.ghosts[event1.entid] = event2.entid
        }

    }

    leave(playerId) {
        console.log("leave lobby", playerId)

        this.map.map.sendObjectDestroyEvent(this.player2entity[playerId])
        delete this.player2entity[playerId]

        if (this.players[playerId]) {
            delete this.players[playerId]
        }


    }

    onMessage(playerId, message) {

        if (this.map.acceptsEvent(message.type)) {
            this.map.receiveMessage(playerId, message)

            if (message.entid in this.ghosts) {
                const ghost = Object.assign({}, message);
                ghost.entid = this.ghosts[message.entid]
                console.log("send ghost", ghost)
                this.sendBroadcast(playerId, ghost)
            }
        } else {
            console.log("unreconized message", playerId, message)
        }


    }

    update(dt) {
        super.update();

        //this.map.reconcile()
        this.map.update(dt)

        while (this.map.map.outgoing_messages.length > 0) {
            const msg = this.map.map.outgoing_messages.shift()
            switch (msg.kind) {
            case 1:
                this.sendMessage(msg.playerId, msg.message)
                break;
            case 2:
                this.sendNeighbors(msg.playerId, msg.message)
                break;
            case 3:
                this.sendBroadcast(msg.playerId, msg.message)
                break;
            default:
                console.log("invalid message type", msg)
                break
            }
        }


        this.world_timer -= dt
        if (this.world_timer < 0) {
            this.send_sync()
            this.world_timer += 0.1
        }

    }

    send_sync() {
        for (const playerId of Object.keys(this.players)) {
            webrtc.xsend(playerId, {type: "map-sync", step: this.map.map.local_step, sync: 0})
        }
    }


}

class DemoServerEngine extends ServerEngine {

    constructor() {
        super();

        this.players = {}

        this.default_lobby_id = 0
    }

    init() {
        console.log("server start")
        console.log("start this",this, this.send_sync)

    }


    connect(playerId) {
        console.log("connect", playerId)

        if (!this.lobbies[this.default_lobby_id]) {
            this.lobbies[this.default_lobby_id] = new DemoLobby();
        }

        this.players[playerId] = true
        this.addPlayerToLobby(playerId, this.default_lobby_id)

        webrtc.xsend(playerId, {type: "connect", playerId})
        console.log("connection sent for", playerId)

        return 0;
    }

    disconnect(playerId) {

        if (playerId in this.playerId2lobbyId) {
            const lobbyId = this.playerId2lobbyId[playerId]
            console.log("disconnect: remove player from lobby", lobbyId)
            this.lobbies[lobbyId].leave(playerId)
        } else {
            console.log("disconnect: player not in any lobby")
        }

        if (this.players[playerId]) {
            delete this.players[playerId]
        }

        console.log("disconnect", playerId)

        return 0;
    }

    onMessage(playerId, message) {

        if (message.type == "keepalive") {
            // echo the message back
            webrtc.xsend(playerId, message)
        }
        else if (playerId in this.playerId2lobbyId) {

            const lobbyId = this.playerId2lobbyId[playerId]
            this.lobbies[lobbyId].onMessage(playerId, message)
        }



        return 0;
    }

    update(dt) {

        for (const [lobbyId, lobby] of Object.entries(this.lobbies)) {
            lobby.update(dt)
        }

        return 0;
    }



}

// ---------------------------
// todo: this should be auto generated by the python framework and exports
const _instance = new DemoServerEngine();
export const server = {}
server.init = () => {_instance.init()}
server.connect = _instance.connect.bind(_instance);
server.disconnect = _instance.disconnect.bind(_instance);
server.onMessage = _instance.onMessage.bind(_instance);
server.update = (dt) => {_instance.update(dt)};

